(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{466:function(t,a,r){"use strict";r.r(a);var s=r(54),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"redis实现bloomfilter-布隆过滤器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis实现bloomfilter-布隆过滤器"}},[t._v("#")]),t._v(" Redis实现BloomFilter-布隆过滤器")]),t._v(" "),r("h2",{attrs:{id:"布隆过滤器-bloom-filter"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器-bloom-filter"}},[t._v("#")]),t._v(" 布隆过滤器 bloom filter")]),t._v(" "),r("p",[t._v("布隆过滤器Bloom Filter是1970年由布隆提出的，它实际上是一个很长的二进制向量和一系列的随机映射函数。\n布隆过滤器可以用于检索一个元素是否在一个集合中。\n布隆过滤器的优点是空间效率和查询查询时间都比一般的算法好的多，缺点是有一定的误判率和删除困难")]),t._v(" "),r("h2",{attrs:{id:"使用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),r("ol",[r("li",[t._v("大量数据去重 ： 大量URL去重、垃圾邮件识别、大集合中重复元素判断")]),t._v(" "),r("li",[t._v("解决缓存穿透 ： 大量恶意流量攻击系统，导致缓存穿透即缓存中没有数据、数据库中也没有的数据")]),t._v(" "),r("li",[t._v("推荐算法： 给A用户推荐过的视频，就不在重复推荐了")])]),t._v(" "),r("h2",{attrs:{id:"具体原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#具体原理"}},[t._v("#")]),t._v(" 具体原理")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"布隆过滤器原理",href:"布隆过滤器原理.png"}},[r("img",{attrs:{src:"%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86.png",alt:"img.png"}})]),t._v("\nBloomFilter需要先分配一块内存空间做bit数组，该数组每一个bit位的初始值均为 0\n加入元素的时候： 采用多个独立的 hash方法计算得到对应的值（多个），这个值（多个）对应bit数组下标，随后将对应下标的数组值bit位改位1，如果未对应上，则不做操作\n判断元素是否存在时：通过多个独立的 hash方法计算得到对应的值（多个），然后根据这个值（多个）找到对应数组下标，获取得到数组的值，如果得到的数组的值全部为1，则存在，如果都为0则不存在")]),t._v(" "),r("p",[t._v("对于布隆过滤器，如果判断某个元素不存在布隆过滤器中，那么这个元素百分百不存在，如果布隆过滤器判断这个元素存在布隆过滤器中，那么这个是有可能存在，也有可能不存在。\n因为Hash碰撞，导致元素和元素的hash值可能存在相同的情况")]),t._v(" "),r("h2",{attrs:{id:"布隆过滤器为什么会有误判率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器为什么会有误判率"}},[t._v("#")]),t._v(" 布隆过滤器为什么会有误判率")]),t._v(" "),r("p",[t._v("因为hash函数会出现hash碰撞")])])}),[],!1,null,null,null);a.default=e.exports}}]);