(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{412:function(a,t,e){"use strict";e.r(t);var s=e(54),l=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"volatile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile"}},[a._v("#")]),a._v(" Volatile")]),a._v(" "),e("h2",{attrs:{id:"java内存模型-java-memory-model-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型-java-memory-model-是什么"}},[a._v("#")]),a._v(" Java内存模型： Java Memory Model 是什么 ？")]),a._v(" "),e("p",[e("a",{attrs:{"data-fancybox":"",title:"java内存模型",href:"java内存模型.png"}},[e("img",{attrs:{src:"java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png",alt:"img.png"}})])]),a._v(" "),e("p",[a._v("JVM是 Java 的内存模型，也就是 Java Memory Model ，本身是一个抽象的概念，实际上不存在，它描述的是一组规则和规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象元素）的访问方式。")]),a._v(" "),e("h2",{attrs:{id:"volatile是啥"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile是啥"}},[a._v("#")]),a._v(" Volatile是啥 ？")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("是Java的一种稍弱同步机制，用来确保将变量更新操作通知到其他线程。\n当变量申明为 volatile 类型的时候，编译器与运行时都会注意到这个变量是共享的，\n因此不会将该变量的操作与其他内存操作一起重排序。\n在访问 volatile 变量的时候不会执行加锁操作，因此不会造成线程阻塞，所以说 volatile 是一种比 Synchronized 更轻量级的同步机制。\n当对非 volatile 变量进行读写的时候，每个线程会从内存中拷贝该变量到 CPU缓存中，如果计算机存在多个 CPU（多核的 CPU），每个线程可能在不同的 CPU上处理，这说明每个线程可以拷贝到不同的 CPU缓存中\n而当变量申明为 volatile 的时候，JVM会让每个线程都从内存中读，从而跳过了 CPU缓存这一步。\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br")])]),e("h2",{attrs:{id:"volatile解决了什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile解决了什么问题"}},[a._v("#")]),a._v(" Volatile解决了什么问题？")]),a._v(" "),e("ol",[e("li",[a._v("多线程中变量可见性问题")]),a._v(" "),e("li",[a._v("CPU指令重排序问题")])]),a._v(" "),e("h2",{attrs:{id:"volatile-和-synchronized-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile-和-synchronized-的区别"}},[a._v("#")]),a._v(" Volatile 和 Synchronized 的区别")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1. Volatile 只能用来修饰变量，Synchronized 可以用修饰方法和代码块\n2. Volatile 不保证原子性，Synchronized 保证原子性\n3. Volatile 不会造成阻塞，而 Synchronized 可能会造成阻塞\n4. Volatile 和 Synchronized 都保证了可见性和有序性\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])])])}),[],!1,null,null,null);t.default=l.exports}}]);