(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{458:function(a,t,s){"use strict";s.r(t);var e=s(54),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"mysql索引数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引数据结构"}},[a._v("#")]),a._v(" Mysql索引数据结构")]),a._v(" "),s("p",[a._v("索引是一种单独的、物理的数据结构对数据库表中一列或者多列值进行排序的一种存储结构，\n也就是说：索引是帮助Mysql高效查询数据的数据结构，索引是存储在磁盘中的\n索引的数据结构为：Hash表和B+树")]),a._v(" "),s("h2",{attrs:{id:"hash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[a._v("#")]),a._v(" Hash ：")]),a._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"Hash表",href:"Hash表.png"}},[s("img",{attrs:{src:"Hash%E8%A1%A8.png",alt:"Hash表.png"}})])]),a._v(" "),s("ol",[s("li",[a._v("Hash的索引数据结构是通过Hash表来保存索引的")]),a._v(" "),s("li",[a._v("Hash 是无序的（类似UUID），要是进行范围查找的话就需要扫描全表。")]),a._v(" "),s("li",[a._v("Hash 值可能存在相同的情况（Hash碰撞、Hash冲突） ，就需要在循环去比较")]),a._v(" "),s("li",[a._v('在需求是查询单条数据的时候可以选择Hash索引，因为Hash索引精准查询最快，比如： 是依赖于这种 where name= "mengqizhang" 这种查询，就在name字段上建立hash索引。\n其他场景下选择B+Tree索引。')])]),a._v(" "),s("h2",{attrs:{id:"b-tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b-tree"}},[a._v("#")]),a._v(" B+Tree")]),a._v(" "),s("p",[a._v("B+树结构示意图\n"),s("a",{attrs:{"data-fancybox":"",title:"B+树结构示意图",href:"B+树结构示意图.png"}},[s("img",{attrs:{src:"B+%E6%A0%91%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:"B+树结构示意图.png"}})])]),a._v(" "),s("ol",[s("li",[a._v("数据只会存在叶子节点上")]),a._v(" "),s("li",[a._v("叶子节点之间加上了链表的关联指针")])]),a._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"B+Tree",href:"B+Tree.png"}},[s("img",{attrs:{src:"B+Tree.png",alt:"B+Tree.png"}})])]),a._v(" "),s("ol",[s("li",[a._v("B+树在节点的数据存储上进行了优化，B树和B+树共同点是一个节点可以存储两个子节点，并且B+树在非叶子节点上不在存放数据（指存放key），这个key就是数据指针地址（数据的key）。")]),a._v(" "),s("li",[a._v("上面的1 和 10 既是叶子节点又是非叶子节点，所以这种情况下查询稍微慢些")]),a._v(" "),s("li",[a._v("上面的B+树就是非叶子节点，多了下面的一个叶子节点，叶子节点通过链表进行了排序（从小到大），所以范围查询的时候更高效，在mysql中order by的字段需要加上索引，")]),a._v(" "),s("li",[a._v("叶子节点包含了非叶子节点的所有数，叶子节点存 数据的key 和 数据，因此B+树遍历整个树只需要遍历叶子节点即可，而B树则需要从根节点一层一层遍历。")]),a._v(" "),s("li",[a._v("非叶子节点只存储 key（数据的key），通过key（数据的key）值找到链表再查询到value值（value就是数据）\nB+树插入数据效果如下图：\n"),s("a",{attrs:{"data-fancybox":"",title:"B+插入数据",href:"B+树插入数据.gif"}},[s("img",{attrs:{src:"B+%E6%A0%91%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.gif",alt:"B+插入数据.gif"}})])])]),a._v(" "),s("p",[a._v("B+树查找数据效果如下图：\n"),s("a",{attrs:{"data-fancybox":"",title:"B+查找数据",href:"B+树查找数据.gif"}},[s("img",{attrs:{src:"B+%E6%A0%91%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE.gif",alt:"B+查找数据.gif"}})])]),a._v(" "),s("p",[a._v("B+树解决了回旋查找的问题，就是通过链表进行查找（可以通过范围查询，B树进行范围查询则需要回旋查找）\n所以mysql中排序需要使用索引排序，因为非叶子节点已经排序好了 （链表从小到大排序）")]),a._v(" "),s("p",[a._v('B树数据结构的索引可以使用在： = 、 > 、 >= 、 < 、 <=、between 运算符的列上比较。并且如果 LIKE 查询不是以通配符开头的常量（"%mengqizhang%"），那么也能使用B树索引进行查询')]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("如下查询会走索引：\nSELECT * FROM tbl_name WHERE key_col LIKE 'Patrick%';\nSELECT * FROM tbl_name WHERE key_col LIKE 'Pat%_ck%';\n\n如下查询不会走索引：\nSELECT * FROM tbl_name WHERE key_col LIKE '%Patrick%'; // 用了通配符 %开头，不走索引\nSELECT * FROM tbl_name WHERE key_col LIKE other_col;  // other_col 不是一个常量值，而是一个字段，也不走索引\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[a._v("问题： 为什么平时数据库表的主键都是要求自增的呢？ 不管是mysql的id自增，还是分布式算法的自增：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("这颗B+树的数据按顺序写入,但是跳过了4,如果后面插进来一个4的key,那树为了维持节点的平衡,就会进行左旋或者右旋,\n在数据量大或者写入密集的情况下,自平衡的动作是非常消耗资源的,所以为了避免这种情况,我们就要让写入的key按顺序自增\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h2",{attrs:{id:"b树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#b树"}},[a._v("#")]),a._v(" B树")]),a._v(" "),s("p",[a._v("结构示意图\n"),s("a",{attrs:{"data-fancybox":"",title:"B树结构示意图",href:"B树结构示意图.png"}},[s("img",{attrs:{src:"B%E6%A0%91%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png",alt:"B树结构示意图.png"}})])]),a._v(" "),s("ol",[s("li",[a._v("B树中每个节点都存储数据：")]),a._v(" "),s("li",[a._v("B树叶子节点中没有指针连接")])]),a._v(" "),s("p",[a._v("B树每个节点不仅存了数据的key只，还存放了数据。\n每页的存储空间是有限的， 如果数据比较大，那么存储的key值就会少，并且会影响树的高度，如果树变高了，从而增加了磁盘的IO，影响查询的效率")]),a._v(" "),s("p",[a._v("B树和B+树有个共同特点就是一个节点可以存储两个值\n"),s("a",{attrs:{"data-fancybox":"",title:"BTree",href:"BTree.png"}},[s("img",{attrs:{src:"BTree.png",alt:"BTree.png"}})])]),a._v(" "),s("p",[a._v("B树插入数据效果如下图：\n"),s("a",{attrs:{"data-fancybox":"",title:"B树插入数据",href:"B树插入数据.gif"}},[s("img",{attrs:{src:"B%E6%A0%91%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.gif",alt:"B树插入数据.png"}})]),a._v("\nB树查找数据效果如下图：\n"),s("a",{attrs:{"data-fancybox":"",title:"B树查找数据",href:"B树查找数据.gif"}},[s("img",{attrs:{src:"B%E6%A0%91%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE.gif",alt:"B树查找数据.png"}})])]),a._v(" "),s("p",[a._v("缺点： 回旋查找比较费劲\n比如需要查找5之后的数据，首先需要查找到5，然后再网上查找到 6 ， 再7，再 8 和 9\nB+树解决了这一个缺点，原因是非叶子节点采用了链表的方式存储了所有的数据。")]),a._v(" "),s("h2",{attrs:{id:"平衡二叉树-avl-tree"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#平衡二叉树-avl-tree"}},[a._v("#")]),a._v(" 平衡二叉树 AVL TREE")]),a._v(" "),s("p",[a._v("基于二叉树之上，平衡二叉树解决了二叉树容易失衡的缺点，保证节点最多两个叶子节点，并且左边一定小于右边\n平衡二叉树插入效果如下：\n"),s("a",{attrs:{"data-fancybox":"",title:"平衡二叉树插入数据",href:"平衡二叉树插入数据.gif"}},[s("img",{attrs:{src:"%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.gif",alt:"平衡二叉树插入数据.gif"}})])]),a._v(" "),s("p",[a._v("平衡二叉树查找数据效果如下：\n"),s("a",{attrs:{"data-fancybox":"",title:"平衡二叉树查找",href:"平衡二叉树查找.gif"}},[s("img",{attrs:{src:"%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE.gif",alt:"平衡二叉树查找.gif"}})])]),a._v(" "),s("p",[a._v("平衡二叉树如果树越高，查找速度就会越慢。\n平衡二叉树到B树（一个节点可以存储两个值），高度变矮了，所以B树的查找速度会比二叉查找树快。")]),a._v(" "),s("p",[a._v("缺点： 平衡二叉树每个节点下的叶子节点只能有2个，导致树阶很高，所以容易造成IO次数过高。")]),a._v(" "),s("h2",{attrs:{id:"二叉树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[a._v("#")]),a._v(" 二叉树")]),a._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"二叉树",href:"二叉树.png"}},[s("img",{attrs:{src:"%E4%BA%8C%E5%8F%89%E6%A0%91.png",alt:"img.png"}})])]),a._v(" "),s("p",[a._v("如上图所示，这是一个普通的二叉树，它有如下特点：")]),a._v(" "),s("ol",[s("li",[a._v("左边节点小于右边节点")]),a._v(" "),s("li",[a._v("每个节点最多就只有2个叶子节点")])]),a._v(" "),s("p",[a._v("二叉树查找也就是折半查找方法，查找和插入的时间变成了O(log(N))，确实一定程度上减缓了io次数\n"),s("a",{attrs:{"data-fancybox":"",title:"二叉树查找",href:"二叉树查找.gif"}},[s("img",{attrs:{src:"%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE.gif",alt:"二叉树查找.gif"}})])]),a._v(" "),s("p",[a._v("缺点：容易失衡\n"),s("a",{attrs:{"data-fancybox":"",title:"二叉树的缺点1",href:"二叉树的缺点1.gif"}},[s("img",{attrs:{src:"%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BC%BA%E7%82%B91.gif",alt:"二叉树的缺点1.gif"}})])])])}),[],!1,null,null,null);t.default=r.exports}}]);