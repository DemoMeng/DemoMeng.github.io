(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{413:function(e,a,n){"use strict";n.r(a);var s=n(54),t=Object(s.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"线程池"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[e._v("#")]),e._v(" 线程池")]),e._v(" "),n("ul",[n("li",[e._v("资源消耗、降低资源消耗：使用已创建的线程来降低线程创建、销毁的消耗")]),e._v(" "),n("li",[e._v("提高响应速度：任务后台执行，不要请求者等待，并且线程池中有空闲的线程等待任务执行")]),e._v(" "),n("li",[e._v("线程管理：线程统一管理、cpu资源由线程池合理分配")])]),e._v(" "),n("h2",{attrs:{id:"线程池创建规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#线程池创建规则"}},[e._v("#")]),e._v(" 线程池创建规则")]),e._v(" "),n("ol",[n("li",[e._v("创建线程池时需要根据服务器资源、性能、应用场景合理分配，配置一下核心线程池参数、线程池最大线程数、队列边界阈值、线程池饱和策略，不设置的话可能会导致请求堆积、最终OOM")]),e._v(" "),n("li",[e._v("最好定义线程池名称，方便线上问题定位")]),e._v(" "),n("li",[e._v("不同的业务使用不同的线程池。多重任务在极端情况下（核心线程池数达阈值，任务在缓冲队列等待被执行），可能出现死锁")])]),e._v(" "),n("h2",{attrs:{id:"executors使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#executors使用"}},[e._v("#")]),e._v(" Executors使用")]),e._v(" "),n("ul",[n("li",[e._v("ExecutorService 接口\n继承者： ScheduledExecutorService 接口\n"),n("ul",[n("li",[e._v("ThreadPoolExecutor 实现类")]),e._v(" "),n("li",[e._v("ScheduledThreadPoolExecutor 继承 （ ThreadPoolExecutor ）实现类")])])])]),e._v(" "),n("p",[e._v("一个 ThreadPoolExecutor，可以额外安排命令在给定延迟后运行，或定期执行。\n当需要多个工作线程时，或者需要额外的灵活性或 ThreadPoolExecutor（此类扩展）的功能时，\n此类比 Timer 更可取。延迟任务在它们被启用后立即执行，但没有任何实时保证在启用后它们何时开始。\n按照先进先出 (FIFO) 提交的顺序启用安排在完全相同的执行时间的任务。当提交的任务在运行之前被取消时，\n执行被抑制。默认情况下，此类取消的任务不会自动从工作队列中删除，直到其延迟结束。虽然这可以进行进一步的检查和监控，\n但它也可能导致取消任务的无限保留。为避免这种情况，请将 setRemoveOnCancelPolicy 设置为 true，\n这会导致任务在取消时立即从工作队列中删除。通过 scheduleAtFixedRate 或 scheduleWithFixedDelay 计划的任务的连续执行不重叠。\n虽然不同的执行可能由不同的线程执行，但先前执行的影响发生在后续执行的影响之前。虽然这个类继承自 ThreadPoolExecutor，\n但一些继承的调优方法对它没有用。特别是，因为它充当使用 corePoolSize 线程和无界队列的固定大小的池，\n所以对 maximumPoolSize 的调整没有有用的效果。此外，将 corePoolSize 设置为零或使用 allowCoreThreadTimeOut\n几乎不是一个好主意，因为一旦它们有资格运行，这可能会使池没有线程来处理任务。\n扩展说明：这个类重写了 execute 和 submit 方法来生成内部 ScheduledFuture 对象来控制每个任务的延迟和调度。\n为了保留功能，在子类中对这些方法的任何进一步覆盖都必须调用超类版本，这有效地禁用了额外的任务定制。\n但是，此类提供了替代的受保护扩展方法 decorateTask（Runnable 和 Callable 各有一个版本），\n可用于自定义用于执行通过 execute、submit、schedule、scheduleAtFixedRate 和 scheduleWithFixedDelay 输入的命令的具体任务类型。\n默认情况下，ScheduledThreadPoolExecutor 使用扩展 FutureTask 的任务类型。但是，这可以使用以下形式的子类进行修改或替换：")]),e._v(" "),n("p",[e._v("Executors是用来创建java中的下线程池：\nExecutors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\nnewFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\nnewScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。\nnewSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br")])]),n("h2",{attrs:{id:"executorservice"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#executorservice"}},[e._v("#")]),e._v(" ExecutorService")]),e._v(" "),n("ul",[n("li",[e._v("ExecutorService关闭：\n使用完ExecutorService后需要关闭，否则其里面的线程一直处于运行状态\n若程序是main函数启动，在main函数结束退出之后，如果ExecutorService没有关闭，这个应用将一直运行，因为ExecutorService中运行的线程会组织JVM关闭")]),e._v(" "),n("li",[e._v("调用ExecutorService.shutdown()后，ExecutorService不会立即关闭，但是不会接收新的任务，直到线程池中所有线程执行完成才会关闭，所有在shutdown()方法执行之前提交的任务都会被执行。")]),e._v(" "),n("li",[e._v("如果想立即停止ExecutorService，ExecutorService.shutdownNow()方法，这个动作会跳过所有正在执行的任务和被提交还未执行的任务。但是它不能保证正在执行任务是否能最终执行完。")])]),e._v(" "),n("h2",{attrs:{id:"threadpoolexecutor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#threadpoolexecutor"}},[e._v("#")]),e._v(" ThreadPoolExecutor")]),e._v(" "),n("ul",[n("li",[e._v("threadPoolExecutor是 ExecutorService 的一个实现类，java中最常用的一个线程池类，ThreadPoolExecutor 内部维护了一个线程只，可以定时执行任务。")]),e._v(" "),n("li",[e._v("构造函数:")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), // 执行器创建新线程时使用的工厂\n             defaultHandler); // 线程池对拒绝任务的处理策略 RejectedExecutionHandler 接口\n}\n\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br")])]),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("使用给定的初始参数和默认线程工厂和被拒绝的执行处理程序创建一个新的 ThreadPoolExecutor。\n使用 Executors 工厂方法之一而不是这个通用构造函数可能更方便。\n参数：\n  corePoolSize - 线程池中保留的线程数，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut \n  maximumPoolSize - 池中允许的最大线程数 \n  keepAliveTime - 当线程数大于核心时，此是多余的空闲线程在终止前等待新任务的最长时间。 \n  unit – keepAliveTime 参数的时间单位 \n  workQueue – 缓冲队列、用于在执行任务之前保存任务的队列。此队列将仅保存由 execute 方法提交的 Runnable 任务。\n  threadFactory – 执行器创建新线程时使用的工厂 \n  handler： RejectedExecutionHandler 接口 ： 线程池拒绝任务处理策略\n抛出： IllegalArgumentException – 如果满足以下条件之一： \n  corePoolSize < 0 \n  keepAliveTime < 0 \n  maximumPoolSize <= 0 \n  maximumPoolSize < corePoolSize \n  NullPointerException – 如果 workQueue 为 null\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br")])]),n("ul",[n("li",[n("p",[e._v("线程数量控制： ThreadPoolExecutor线程池中的线程数量是可变的，其变化范围取决于下面两个变量：")]),e._v(" "),n("ol",[n("li",[e._v("corePoolSize:  线程池中保留的线程数")]),e._v(" "),n("li",[e._v("maximunPoolSize: 池中允许的最大线程数")])])]),e._v(" "),n("li",[n("p",[e._v("ThreadFactory ：创建线程的工厂")]),e._v(" "),n("p",[e._v("使用 hutool 的NamedThreadFactory 设置线程池名称，也可以自己实现 ThreadFactroy")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  \n  // 设置名称线程池名称\n  DefaultThreadFactory() {\n              SecurityManager s = System.getSecurityManager();\n              group = (s != null) ? s.getThreadGroup() :\n                                    Thread.currentThread().getThreadGroup();\n              namePrefix = "pool-" +\n                            poolNumber.getAndIncrement() +\n                           "-thread-";\n          }\n  \n  \n  \n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br")])]),n("ul",[n("li",[e._v("线程池执行一个任务的过程如下：\n"),n("a",{attrs:{"data-fancybox":"",title:"线程池执行任务流程",href:"线程池执行任务流程.png"}},[n("img",{attrs:{src:"%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png",alt:"线程池执行任务流程"}})])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  1. 若此时线程池中的线程数量小于 corePoolSize：及时线程池中其他的线程都是空闲状态，会创建一个新的线程来执行该任务\n  2. 若此时线程池中的线程数量等于 corePoolSize：但是缓冲队列未满，那么任务进入 workQueue 队列缓存，等待线程池中线程空闲后再执行该任务\n    \n  3. 若此时线程池中的线程数量大于 corePoolSize：则判断任务队列 workQueue 是否满了\n  \t\t\t\t\t若 workQueue 满：判断当前的线程池线程数量是否达到 maximumPoolSize 阈值，\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t若池小于 maximumPoolSize：则新建线程执行该任务\t\t\t\t\t\t\t\t\t\t\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t若池大于 maximumPoolSize：则执行 RejectedExecutionHandler 对线程拒绝处理的策略（线程池饱和处理策略）\n  \t\t\t\t\t若 workQueue 不满：则将任务放入缓冲队列中，等待线程池中线程空闲后再执行该任务\n  \n  4. 若此时线程池中的线程数量大于 corePoolSize ， 如果某线程空闲时间超过 KeepAliveTime ，线程就被终止\n    \n  从上面我们可以发现线程池的处理优先级是： corePoolSize > workQueue > maximumPoolSize, 如果这三个都满了则执行线程池饱和处理策略  \n    \n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br")])]),n("ul",[n("li",[e._v("线程池饱和处理策略 : 对应 defaultHandler 参数")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  RejectedExecutionHandler 线程池饱和处理策略，主要有下面4个实现类：\n  \n  ThreadPoolExecutor.AbortPolicy： 默认策略，抛出 java.util.concurrent.RejectedExecutionException 异常\n  ThreadPoolExecutor.DiscardOldestPolicy：丢弃一个最老的任务，再尝试把当前任务丢到线程池使用线程执行\n  ThreadPoolExecutor.CallerRunsPolicy：判断线程池是否关闭，若未关闭则使用调用者的线程执行任务  \n  ThreadPoolExecutor.DiscardPolicy：该策略丢弃无法处理的任务（不处理），如果允许任务丢失（应用有重试任务的机制）情况下，该策略极佳\n  \n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("ul",[n("li",[e._v("workQueue： 是一个阻塞队列")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  默认使用 LinkedBlockingQueue<Runnable>\n  是一个队列，它还支持在检索元素时等待队列变为非空，并在存储元素时等待队列中的空间变为可用的操作。 \n  BlockingQueue 方法有四种形式，用不同的方式处理不能立即满足，但可能在未来某个时间点满足的操作：\n  \t一: 抛出异常，\n    二: 返回特殊值（null 或 false，取决于操作），\n    三: 无限期地阻塞当前线程，直到操作成功，\n    四: 阻塞只有给定的最大时间限制才放弃。\t\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("ul",[n("li",[e._v("workQueue 有几种队列 : FIFO (First In First Out ： 先进先出)")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1. ArrayBlockingQueue \n\n2. LinkedBlockingQueue\n\n3. SynchronousQueue:\n\n4. PriorityBlockingQueue:\n\n\n5. DelayQueue : \n\n6. LinkedTransferQueue:\n\n\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br")])]),n("ul",[n("li",[n("p",[e._v("手动创建一个 ThreadPoolExecutor")]),e._v(" "),n("p",[e._v("使用 hutool 的NamedThreadFactory 设置线程池名称，也可以自己实现 ThreadFactroy")])])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n  \t\t\t\t\t\t\t\t\t\tcorePoolSize,\n                      maxPoolSize,\n                      50000,\n                      TimeUnit.SECONDS,\n                      new LinkedBlockingQueue<Runnable>(),\n                      new NamedThreadFactory("线程池名称-1"));\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("ul",[n("li",[e._v("避免使用 Executors 创建 newCachedThreadPool() 和")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  maximumPoolSize = Integer.MAX_VALUE 设置线程池中最大线程数量为 Integer的最大值，可能导致请求堆积，导致OOM\n  public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {\n          return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                        60L, TimeUnit.SECONDS,\n                                        new SynchronousQueue<Runnable>(),\n                                        threadFactory);\n      }\n  \n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br")])]),n("h2",{attrs:{id:"scheduledthreadpoolexecutor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#scheduledthreadpoolexecutor"}},[e._v("#")]),e._v(" ScheduledThreadPoolExecutor")]),e._v(" "),n("p",[e._v("继承了 ThreadPoolExecutor，直接实现接口 ScheduledExecutorService （继承了 ExecutorService）")]),e._v(" "),n("ol",[n("li",[e._v("相比于ThreadPoolExecutor 用于任务调度，定时、延迟执行任务")]),e._v(" "),n("li",[e._v("使用自定义的队列 DelayedWorkQueue，无界DelayQueue的一种变体。与 ThreadPoolExecutor 相比，缺乏容量限制以及 corePoolSize 和 maximumPoolSize 实际上相同的事实简化了一些执行机制，但是容易引发内存飙升导致OOM")]),e._v(" "),n("li",[e._v("支持可选的run-after-shutdown参数，这会导致关闭方法的覆盖以删除和取消不应在关闭后运行的任务，以及当任务（重新）提交与关闭重叠时不同的重新检查逻辑。")]),e._v(" "),n("li",[e._v("允许拦截和检测的任务修饰方法，这是必需的，因为子类不能以其他方式覆盖提交方法来获得这种效果。但是，这些对池控制逻辑没有任何影响。")])]),e._v(" "),n("p",[e._v("构造函数参考 ThreadPoolExecutor")]),e._v(" "),n("ul",[n("li",[e._v("主要方法")])]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  public ScheduledFuture<?> schedule(Runnable command,long delay,TimeUnit unit) {}\n  指定延迟 delay 时间，单位 unit，执行 command 任务，这个方法没有办法获取 command 的返回值。如果想要获取 command的返回值\n  需要传入一个 Callable 回调\n  \n  public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit) {}\n  周期新执行任务，延迟 initialDelay，间隔 period\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n  public void execute(Runnable command) {}\n  方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\n  \n  \n  public Future<?> submit(Runnable task) {}\n  方法返回一个Future对象，可以判断任务是否执行成功，传入 Callable 并且可以通过Future的get方法获取到task的返回值\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);