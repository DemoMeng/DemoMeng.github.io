(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{418:function(a,s,t){"use strict";t.r(s);var n=t(54),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("ol",[t("li",[a._v("键不可重复，值可以重复")]),a._v(" "),t("li",[a._v("key可以为null,值也可以为null （null的可以只能有一个）")]),a._v(" "),t("li",[a._v("线程不安全的\n1.7 头插法导致多线程情况下出现死循环\n1.8 多线程下发生数据覆盖的问题：当数组中没有元素，刚好两个线程执行的hash值一样，导致A线程执行完put进去后，未执行结束，然后B线程又put进去了，导致值覆盖了")])]),a._v(" "),t("h2",{attrs:{id:"hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable"}},[a._v("#")]),a._v(" HashTable ：")]),a._v(" "),t("ol",[t("li",[a._v("键不可重复，值可以重复")]),a._v(" "),t("li",[a._v("key和value 都不能 null")]),a._v(" "),t("li",[a._v("线程安全的 (所有的方法都加上了 synchronized)")]),a._v(" "),t("li",[a._v("效率非常低下，当一个线程访问同步方法，另外一个线程将进入阻塞状态，即不能调用 get() 也不能调用 put() 方法")])]),a._v(" "),t("h2",{attrs:{id:"数组和链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组和链表"}},[a._v("#")]),a._v(" 数组和链表")]),a._v(" "),t("p",[a._v("数组： 查找块，增加和删除慢（需要根据下标变动）\n内存空间是连续的")]),a._v(" "),t("p",[a._v("链表：增加和删除块（直接修改链表的引用地址），查询慢（因为链表没有index,只能从头开始查询所有的元素）\n内存不连续的，前一个链表保存下一个链表的引用地址")]),a._v(" "),t("h2",{attrs:{id:"hashmap-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-2"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),t("p",[a._v("简单说下HashMap的实现原理，首先有一个每个元素都是链表（可能表述不准确）的数组，\n当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，\n但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，\n他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。\n而当链表长度太长时，链表就转换为红黑树， 这样大大提高了查找的效率。")]),a._v(" "),t("p",[a._v("在jdk8中，HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（>8个），\n采用红黑树（特点是查询时间是O（logn））存储（有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储）")]),a._v(" "),t("h5",{attrs:{id:"hashmap-底层定义了6个常量-用来控制底层的结构-jdk1-8使用的是数组-链表-红黑树-链表元素改为了尾插法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-底层定义了6个常量-用来控制底层的结构-jdk1-8使用的是数组-链表-红黑树-链表元素改为了尾插法"}},[a._v("#")]),a._v(" HashMap 底层定义了6个常量，用来控制底层的结构 (JDK1.8使用的是数组+链表+红黑树，链表元素改为了尾插法)")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 默认初始容量为16，也就是数组（习惯称为桶）的大小为16，这里数组的容量是可变的，数组的容量必须为2的次幂\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n\n// 最大容量为\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n\n// 默认的扩容系数，这里指的是数组什么时候会扩容，指的是为初始容量为16，默认扩容系数为0.75，那么16*0.75 = 12，当元素超过12时，就会触发扩容\n// 后续会根据数组的容量和这个扩容系数进行比较，判断是否需要扩容 \nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n// 链表元素超过多少时候，会转化程红黑树的结构进行存储，因为链表查询效率很慢的 \nstatic final int TREEIFY_THRESHOLD = 8;\n\n// 链表元素少于多少的时候，红黑树结构会转为链表的结构\nstatic final int UNTREEIFY_THRESHOLD = 6;\n\n// 最小的数组阈值，64，即当数组的长度小于64的时候，无论链表元素超过了8，链表都不会转程红黑树的结构进行存储，而是先采取扩容\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br")])]),t("h5",{attrs:{id:"底层结构详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#底层结构详解"}},[a._v("#")]),a._v(" 底层结构详解")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("按照HashMap默认构造方法来，会创建一个容量为16的数组，会将元素添加到数组中，（发生了hash碰撞）如果数组中有元素，则会在该下标中形成一个链表\n"),t("a",{attrs:{"data-fancybox":"",title:"hashMap步骤1",href:"hashMap步骤1.png"}},[t("img",{attrs:{src:"hashMap%E6%AD%A5%E9%AA%A41.png",alt:"img.png"}})])])]),a._v(" "),t("li",[t("p",[a._v("继续添加元素则会触发HashMap的扩容机制，即： 数组容量*扩容系数 ，当扩容后的数组容量超过了64 （默认设置的最小数组容量），并且数组中的一个链表内的元素超过了8\n那么该链表则会转换为红黑树的结构存储链表的元素\n"),t("a",{attrs:{"data-fancybox":"",title:"hashMap步骤2",href:"hashMap步骤2.png"}},[t("img",{attrs:{src:"hashMap%E6%AD%A5%E9%AA%A42.png",alt:"img.png"}})]),a._v("\n如果链表中元素删除后导致红黑树结构中的元素小于6，则该红黑树又会变成链表结构")])])]),a._v(" "),t("h5",{attrs:{id:"元素定位数组的算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元素定位数组的算法"}},[a._v("#")]),a._v(" 元素定位数组的算法")]),a._v(" "),t("ul",[t("li",[a._v("如何将元素定位存到数组中的，这里使用的是key.hasCode()，并和数组的容量-1进行取位运算（这里的取位就是取模运算）,\n我们再来看看这个方法返回的是什么。h & (length - 1) ，这句代码目的是求出数组中的下标，用来存放当前这对键值对，那求出的值必须在 0 - (lenght - 1) 之内，\n因此我们可以大胆猜测，这就是一个求模运算！可是 & 和 % 肯定是不同的操作，按位与怎么就相当于求模运算了呢？ 这正是因与 length 特殊的限定有关。\n因为 length 是一个 2的幂次方的数 ，因此减去1后，低位每一位都是1。比如 length = 16，减去以1后就是 00001111，这时候再与 h 按位与就相当于 length 和 h 求模运算了。\n因此 length是2的幂次方 ，此外转化成二进制后，1 分布得很均匀，与 h 按位与时得出的结果在 length 上也是均匀的，从而在数组中也是均匀分布，所以有效减少了 hash碰撞 ， 而且位运算的效率是高于求模运算的。")])]),a._v(" "),t("p",[a._v("具体代码如下：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 确定当前键值对存放在数组中的下标 （JDK 1.7）\nstatic int indexFor(int h, int length) {\n    // 用计算出的 hash 按位与 上(length - 1)，算出对应数组的下标\n    return h & (length - 1);\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("h5",{attrs:{id:"jdk1-7-使用的是数组-链表-并且链表元素采用的头插法-这是造成扩容死循环的原因之一"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-7-使用的是数组-链表-并且链表元素采用的头插法-这是造成扩容死循环的原因之一"}},[a._v("#")]),a._v(" JDK1.7 使用的是数组+链表，并且链表元素采用的头插法（这是造成扩容死循环的原因之一）")]),a._v(" "),t("p",[a._v("JDK1.7之前的HashMap采用的数组+链表的底层结构进行存储数据，至于hash定位元素在数组下标基本没改动（JDK1.8优化了一下hash的算法，减少了hash碰撞的概率）\n"),t("a",{attrs:{"data-fancybox":"",title:"JDK7和8区别1",href:"JDK7和8区别1.png"}},[t("img",{attrs:{src:"JDK7%E5%92%8C8%E5%8C%BA%E5%88%AB1.png",alt:"img.png"}})])]),a._v(" "),t("h4",{attrs:{id:"hashmap的-put方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的-put方法"}},[a._v("#")]),a._v(" HashMap的 put方法")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("1. hash(key)定位到了数组的某下标，若该下标中没有元素就直接插入\n2. 如果定位的下标的数组中有元素，则需要和key值进行比较，如果一致那么就覆盖，如果key不同，那么判断链表是不是一个红黑树节点，如果是则将元素添加到红黑数中，\n   如果不是，那么就是一个链表，则便利链表，并且在尾部插入（1.7是头部插入）\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("h2",{attrs:{id:"面试问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面试问题"}},[a._v("#")]),a._v(" 面试问题")]),a._v(" "),t("ul",[t("li",[t("ol",[t("li",[a._v("HashMap引入红黑树有什么优势？")])])])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("红黑树是一个特殊的二叉查找树，它的每一个节点都又一个颜色，非黑即红，所有 null 节点都是叶子节点，并且和跟跟节点一样，都是黑色。\n引入红黑树的意义目的就是解决hash碰撞次数过多而导致同一个数组存储的链表元素过多，查询耗费时间的问题。\n有了红黑树，查询链表元素的效率提升至 O(logn)，类似二分查找法，效率高\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br")])]),t("ul",[t("li",[t("ol",{attrs:{start:"2"}},[t("li",[a._v("JDK1.7中 HashMap扩容为什么会死循环？")])])])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("JDK1.7中链表插入元素的方式是头插法，这就会导致若两个线程同时去扩容 HashMap 的时候，出现一个线程执行到一半，比如执行得到 e 和 next ,这时另外一个线程抢占了CPU时间片并且将\nHashMap扩容完成，此时HashMap中链表是一个倒序，这个时候第一个线程再继续去扩容时，第一得到的 e 就会访问两次，再链表插入两次，这就会熬制循环数据的产生，从而访问时形成死循环。\n虽然说 JDK1.8 改为了尾插法方式解决了改问题，但是HashMap仍旧是线程不安全的，并发的场景下还是需要使用 ConcurrentHashMap !!\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("h2",{attrs:{id:"hashmap-线程不安全解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-线程不安全解决方案"}},[a._v("#")]),a._v(" HashMap 线程不安全解决方案：")]),a._v(" "),t("ol",[t("li",[a._v("使用 Collections.synchronizedMap()")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Map<String, Object> map2 = Collections.synchronizedMap(new HashMap<String,Object>());\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("使用 JUC 中的 ConcurrentHashMap<>()")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("ConcurrentHashMap<String, Object> cMap = new ConcurrentHashMap<String,Object>();\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h2",{attrs:{id:"concurrenthashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap :")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\nJDK 1.7: ConcurrentHashMap 是对数组进行了分割分段也就是所说的:Segment （分段锁），每一把锁只锁Map中一部分数据，多线程访问不同的数据就减少了锁竞争，提高并发访问率。\nJDK 1.8: 取消了 segment的概念，转而是使用 node数组+链表+红黑树的结构来实现，并发控制使用 synchronized 和 CAS来操作。基本和 HashMap 1.8一样，有些地方保留了 segment 是为了兼容旧版本。\n              \n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("h5",{attrs:{id:"红黑树的概念-原理是什么-有什么优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#红黑树的概念-原理是什么-有什么优势"}},[a._v("#")]),a._v(" 红黑树的概念，原理是什么，有什么优势")]),a._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"红黑树结构",href:"红黑树结构.png"}},[t("img",{attrs:{src:"%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.png",alt:"img.png"}})])]),a._v(" "),t("ol",[t("li",[a._v("每个节点不是红色就是黑色")]),a._v(" "),t("li",[a._v("不可能有个连在一起的红色节点，黑色节点可以相连")]),a._v(" "),t("li",[a._v("根节点都是黑色")]),a._v(" "),t("li",[a._v("每个红色节点的子节点都是黑色，叶子节点都是黑色 （N：L 存在隐藏的节点导致叶子节点不是黑色）")])]),a._v(" "),t("p",[a._v("为了满足红黑树的特性，所以出现了三种旋转：")]),a._v(" "),t("ol",[t("li",[a._v("改变颜色")]),a._v(" "),t("li",[a._v("左旋")]),a._v(" "),t("li",[a._v("右旋")])])])}),[],!1,null,null,null);s.default=e.exports}}]);