(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{457:function(a,r,s){"use strict";s.r(r);var e=s(54),n=Object(e.a)({},(function(){var a=this,r=a.$createElement,s=a._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"apacheshardingsphere"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#apacheshardingsphere"}},[a._v("#")]),a._v(" ApacheShardingSphere")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("定义\n定位为 Database Plus，目的是构建异构数据库上层的标准和生态，说白了就是屏蔽关系型数据库之间的区别，构建统一的操作平台")])]),a._v(" "),s("li",[s("p",[a._v("核心概念")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("连接： 通过对数据库协议、SQL 方言以及数据库存储的灵活适配，快速的连接应用与多模式的异构数据库")])]),a._v(" "),s("li",[s("p",[a._v("增量： 获取数据库的访问流量，并且提供流量的重定向（数据分片，读写分离，影子库）、流量变形（数据加密，数据脱敏）、流量鉴权（安全、审计、权限）\n流量治理（熔断、限流）以及流量分析（服务质量分析、可观察性）等透明化增量功能")])]),a._v(" "),s("li",[s("p",[a._v("可插拔： 项目采用微内核 + 三层可插拔模型，使内核、功能组件以及生态对接完全能够灵活的方式进行插拔式扩展，开发者能够像使用积木一样定制属于自己的独特系统。")])])])]),a._v(" "),s("li",[s("p",[a._v("架构图\n"),s("a",{attrs:{"data-fancybox":"",title:"111",href:"ApacheShardingSphere架构.png"}},[s("img",{attrs:{src:"ApacheShardingSphere%E6%9E%B6%E6%9E%84.png",alt:"img.png"}})])])]),a._v(" "),s("li",[s("p",[a._v("产品")]),a._v(" "),s("ul",[s("li",[a._v("Sharding JDBC")]),a._v(" "),s("li",[a._v("SHarding Proxy")]),a._v(" "),s("li",[a._v("Sharding Sidecar（todo中）")])])]),a._v(" "),s("li",[s("p",[a._v("产品对比\n"),s("a",{attrs:{"data-fancybox":"",title:"111",href:"ApacheShardingSphere产品对比.png"}},[s("img",{attrs:{src:"ApacheShardingSphere%E4%BA%A7%E5%93%81%E5%AF%B9%E6%AF%94.png",alt:"img.png"}})])])]),a._v(" "),s("li",[s("p",[a._v("发展历程\n"),s("a",{attrs:{"data-fancybox":"",title:"111",href:"ApacheShardingSphere发展历程.png"}},[s("img",{attrs:{src:"ApacheShardingSphere%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B.png",alt:"img_1.png"}})])])])]),a._v(" "),s("h2",{attrs:{id:"sharding-jdbc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sharding-jdbc"}},[a._v("#")]),a._v(" Sharding JDBC")]),a._v(" "),s("p",[a._v("定位为轻量级的Java框架，在java的JDBC层提供额外的服务。它使用客户端直连数据库，以Jar依赖的方式提供服务，无需外部部署和依赖，可以理解为增强版的JDBC，完全兼容JDBC和ORM框架")]),a._v(" "),s("ul",[s("li",[a._v("适配JDBC的ORM框架： Mybatis、JPA、Hibernate、Spring的JDBCTemplate")]),a._v(" "),s("li",[a._v("支持第三方的数据库连接池： DBCP，C3P0，")]),a._v(" "),s("li",[a._v("支持可以使用JDBC（）访问的数据库：Mysql、PostgreSQL、Oracle、SqlServer")])]),a._v(" "),s("p",[a._v("架构图：\n"),s("a",{attrs:{"data-fancybox":"",title:"111",href:"ShardingJDBC架构图.png "}},[s("img",{attrs:{src:"ShardingJDBC%E6%9E%B6%E6%9E%84%E5%9B%BE.png",alt:"img.png"}})])]),a._v(" "),s("h4",{attrs:{id:"分片和分库相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分片和分库相关"}},[a._v("#")]),a._v(" 分片和分库相关")]),a._v(" "),s("p",[a._v("一般我们提到的分库分表，都是以水平切分模式（水平分库、水平分表），数据分片将原先数据量大的一张表：user，划分成几个表结构完全一致的小数据量表：user0,user1,user2 .....\n每张表只存之前user表中的一部分数据，当之前SQL的时候（插入、修改）会根据分库策略，分表策略将数据分散到不同的数据库、表中。")]),a._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"分库分表流程",href:"分库分表流程.png "}},[s("img",{attrs:{src:"%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%B5%81%E7%A8%8B.png",alt:"img.png"}})])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("数据节点：\n数据节点是分库分表中一个不可再分的最小数据单元（表），它由数据库名和数据表名组成，例如：db0.user0")])]),a._v(" "),s("li",[s("p",[a._v("逻辑表：\n逻辑表是指的一组具有相同逻辑、数据结构、表结构的表的总称。例如我们将user表拆分成：user0、user1，\n这个时候发现数据库中是没有user这个表，取而代之的是：user0、user1表。这样这个user表是逻辑表")])]),a._v(" "),s("li",[s("p",[a._v("真实表：\n指的是上面提到的：user0、user1 数据库中存在真实的物理表")])]),a._v(" "),s("li",[s("p",[a._v("分片键：\n用于分片的数据库字段，我们将user表进行分片，用id作为分片的字段，id进行取模，决定了这条数据应该保存到哪个表，这个id就是user表分片键\nsharding JDBC支持将多个字段进行分片")])]),a._v(" "),s("li",[s("p",[a._v("分片算法：\n取模只是最简单的一种分片算法，在实际开发中我们还可能希望用： > 、 < 、 >= 、<= 、between 、 in 等条件作为分片规则，自定义分片逻辑，\n这个时候需要用到分片算法和分片策略。")])])]),a._v(" "),s("p",[a._v("从SQL角度来看，分片算法其实就是一种路由规则，SQL路由到我们需要到的数据库和表。")]),a._v(" "),s("p",[a._v("sharding JDBC 提供了4中分片算法：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("1. 精确分片算法（PreciseShardingAlgorithm）用于单个字段作为分片键，SQL中有 = 与 IN 等条件的分片，需要在标准分片策略（StandardShardingStrategy ）下使用\n2. 范围分片算法（RangeShardingAlgorithm）用于单个字段作为分片键，SQL中有 BETWEEN AND、>、<、>=、<= 等条件的分片，需要在标准分片策略（StandardShardingStrategy ）下使用。\n3. 复合分片算法（ComplexKeysShardingAlgorithm）用于多个字段作为分片键的分片操作，同时获取到多个分片健的值，根据多个字段处理业务逻辑。需要在复合分片策略（ComplexShardingStrategy ）下使用。\n4. Hint分片算法（HintShardingAlgorithm）稍有不同，上边的算法中我们都是解析SQL 语句提取分片键，并设置分片策略进行分片。但有些时候我们并没有使用任何的分片键和分片策略，可还想将 SQL 路由到目标数据库和表，就需要通过手动干预指定SQL的目标数据库和表信息，这也叫强制路由。\n\n\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br")])]),s("ul",[s("li",[a._v("分片策略\n分片策略是一个抽象的概念，它包含了分片算法和分片键，\n1、标准分片策略")])]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("标准分片策略适用于单分片键，此策略支持 PreciseShardingAlgorithm 和 RangeShardingAlgorithm 两个分片算法。\n其中 PreciseShardingAlgorithm 是必选的，用于处理 = 和 IN 的分片。\nRangeShardingAlgorithm 是可选的，用于处理BETWEEN AND， >， <，>=，<= 条件分片，\n如果不配置RangeShardingAlgorithm，SQL中的条件等将按照全库路由处理。  \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("2、复合分片策略")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("复合分片策略，同样支持对 SQL语句中的 =，>， <， >=， <=，IN和 BETWEEN AND 的分片操作。\n不同的是它支持多分片键，具体分配片细节完全由应用开发者实现。\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("3、行表达式分片策略")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("行表达式分片策略，支持对 SQL语句中的 = 和 IN 的分片操作，但只支持单分片键。\n这种策略通常用于简单的分片，不需要自定义分片算法，可以直接在配置文件中接着写规则。\n\nt_order_$->{t_order_id % 4} 代表 t_order 对其字段 t_order_id取模，拆分成4张表，而表名分别是t_order_0 到 t_order_3。\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("4、Hint分片策略")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("Hint分片策略，对应上边的Hint分片算法，通过指定分片健而非从 SQL中提取分片健的方式进行分片的策略。\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("ul",[s("li",[a._v("分布式主键\n数据分片后，不同数据节点的主键已经不能按照之前自动递增来设置了，仅仅是在同一个库的一个逻辑表对应多个真实表，这些表的id均不能重复。")])]),a._v(" "),s("p",[a._v("sharding JDBC提供了 UUID 和 snowflake 两种方式生成分布式id。默认是雪花算法生成分布式id，")]),a._v(" "),s("ul",[s("li",[a._v("广播表：\n定义： 指的是所有分片数据源中都存在的表，并且每个库表接口、数据都一摸一样\n适用： 数据量不⼤且需要与海量数据的表进⾏关联查询的场景，例如：字典表、公共配置表")])]),a._v(" "),s("p",[a._v("满足条件：\n（1）在每个数据库表都存在该表以及表结构都⼀样。\n（2）当保存的时候，每个数据库都会保存一份一摸一样的数据")]),a._v(" "),s("ul",[s("li")]),a._v(" "),s("h4",{attrs:{id:"分库分表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[a._v("#")]),a._v(" 分库分表")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("- 定义： 拆分一个数据库为多个数据库、一个表为多个表\n- 为什么：\n   1. 性能问题 ： 请求增加并发请求，若sql没走索引扫描全表导致占用数据库资源，影响其他的请求。\n   2. 存储空间不够 ： 数据量增加，服务器的磁盘空间越来越少。\n   3. 可用性更高 ： 避免单点故障的问题，当一个数据库故障后其他数据库可以提供服务。\n   4. 业务划分 ： 针对springcloud微服务、多团队开发\n \n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("h4",{attrs:{id:"分库-垂直拆分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分库-垂直拆分"}},[a._v("#")]),a._v(" 分库- 垂直拆分")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("- 根据业务范围不同，划分用户库、商品库、订单库等\n- 需要这这库在不同的数据库服务器实例上才会提高数据库的性能\n- 这样也解决了数据存储空间的问题。三个数据库实例存储的数据比不分库之前存量大\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("h4",{attrs:{id:"分表-水平拆分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分表-水平拆分"}},[a._v("#")]),a._v(" 分表- 水平拆分")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("- 用户表拆分成 用户表-1、用户表-2、用户表-3\n- 拆分规则可以按照生成id的奇偶树、取模等\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("h2",{attrs:{id:"sharding-proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sharding-proxy"}},[a._v("#")]),a._v(" Sharding Proxy")]),a._v(" "),s("p",[a._v("定位为透明的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言（异构数据库）的支持")]),a._v(" "),s("ul",[s("li",[a._v("支持Mysql、 支持PostgreSQL： openGauss基于PostgreSQL也支持")]),a._v(" "),s("li",[a._v("对于应用程序完全透明，可以直接替换mysql、PostgreSQL操作使用")]),a._v(" "),s("li",[a._v("适用于任何兼容Mysql 、 PostgreSQL协议的客户端")])]),a._v(" "),s("p",[a._v("架构图\n"),s("a",{attrs:{"data-fancybox":"",title:"111",href:"ShardingProxy架构图.png "}},[s("img",{attrs:{src:"ShardingProxy%E6%9E%B6%E6%9E%84%E5%9B%BE.png",alt:"img.png"}})])]),a._v(" "),s("h2",{attrs:{id:"sharding-sidecar"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sharding-sidecar"}},[a._v("#")]),a._v(" Sharding Sidecar")]),a._v(" "),s("p",[a._v("定位为 Kubernetes 的云原生数据库代理，以 Sidecar 的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的啮合层，即 Database Mesh，又可称数据库网格。\nDatabase Mesh 的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互进行有效地梳理。\n使用 Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。")]),a._v(" "),s("p",[a._v("架构图\n"),s("a",{attrs:{"data-fancybox":"",title:"111",href:"ShardingSidecar架构图.png "}},[s("img",{attrs:{src:"ShardingSidecar%E6%9E%B6%E6%9E%84%E5%9B%BE.png",alt:"img.png"}})])]),a._v(" "),s("h2",{attrs:{id:"shardingjdbc-和-shardingproxy-混合使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#shardingjdbc-和-shardingproxy-混合使用"}},[a._v("#")]),a._v(" ShardingJDBC 和 ShardingProxy 混合使用")]),a._v(" "),s("ul",[s("li",[a._v("ShardingJDBC采用的是无中心化架构，和java应用程序共享资源，适用于Java开发的高性能轻量级OLTP应用")]),a._v(" "),s("li",[a._v("ShardingProxy提供静态入口以及异构语言的的支持、独立部署、适用于 OLAP 应用，以及对分片数据库进行管理和运维的场景")])]),a._v(" "),s("p",[a._v("ApacheShardingSphere 通过混合使用 ShardingJDBC 和 ShardingProxy，采用同一个注册中心统一配置分片策略，能够灵活搭建各种场景的应用系统。（三高系统）")]),a._v(" "),s("ul",[s("li",[a._v("架构图\n"),s("a",{attrs:{"data-fancybox":"",title:"111",href:"ShardingJDBC和ShardingProxy混合使用.png "}},[s("img",{attrs:{src:"ShardingJDBC%E5%92%8CShardingProxy%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8.png",alt:"img.png"}})])])]),a._v(" "),s("h2",{attrs:{id:"apacheshardingsphere产品提供的解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#apacheshardingsphere产品提供的解决方案"}},[a._v("#")]),a._v(" ApacheShardingSphere产品提供的解决方案")]),a._v(" "),s("p",[s("a",{attrs:{"data-fancybox":"",title:"111",href:"ApacheShardingSphere提供的解决方案.png"}},[s("img",{attrs:{src:"ApacheShardingSphere%E6%8F%90%E4%BE%9B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png",alt:"img.png"}})])])])}),[],!1,null,null,null);r.default=n.exports}}]);