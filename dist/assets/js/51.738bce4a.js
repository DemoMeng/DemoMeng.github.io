(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{440:function(s,e,a){"use strict";a.r(e);var t=a(54),n=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[s._v("#")]),s._v(" 分布式锁")]),s._v(" "),a("p",[s._v("分布式锁就是控制分布式系统（不同进程）共同访问同一个资源的一种锁的实现。不同系统、相同系统不同主机（服务集群）")]),s._v(" "),a("h2",{attrs:{id:"为什么需要分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要分布式锁"}},[s._v("#")]),s._v(" 为什么需要分布式锁")]),s._v(" "),a("ol",[a("li",[s._v("在WEB项目中，如果是单机部署的情况下，可以使用JAVA的 synchronized 或者 ReentrantLock 进行资源进行锁的控制。")]),s._v(" "),a("li",[s._v("但是在分布式系统中，项目的分开部署、集群、多线程的场景下，靠单个系统进行 synchronized 进行上锁就无法做到资源控制，无法到达数据最终一致。")]),s._v(" "),a("li",[s._v("所以基于以上的背景，需要有一个跨JVM的中间件来统一控制资源的访问，简单来说就是WEB项目在多个进程中，就需要使用到分布式锁！")])]),s._v(" "),a("h2",{attrs:{id:"线程锁-和-进程锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程锁-和-进程锁"}},[s._v("#")]),s._v(" 线程锁 和 进程锁")]),s._v(" "),a("p",[s._v("线程锁：\n主要是给方法加锁，当某个方法使用锁，在同一个时刻只有一个线程执行该方法。\n线程锁只会在同一个JVM中有效果，因为线程锁实现的原理就是依靠线程之间共享内存实现的。\njava中的线程锁有： Synchronized 和 Lock")]),s._v(" "),a("p",[s._v("进程锁：\n为了多个进程访问相同资源，因为进程都是独立的，无法共享内存内存资源，所以无法通过 Synchronized 和 Lock 实现进锁")]),s._v(" "),a("h2",{attrs:{id:"实现方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[s._v("#")]),s._v(" 实现方式")]),s._v(" "),a("ul",[a("li",[s._v("数据库实现分布式锁")]),s._v(" "),a("li",[s._v("Redis实现分布式锁")]),s._v(" "),a("li",[s._v("Zookeeper实现分布式锁")])]),s._v(" "),a("p",[s._v("x")]),s._v(" "),a("h2",{attrs:{id:"数据库实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库实现分布式锁"}},[s._v("#")]),s._v(" 数据库实现分布式锁")]),s._v(" "),a("ul",[a("li",[s._v("悲观锁实现： 参考 "),a("a",{attrs:{href:"https://gitee.com/DemoMeng/better-skills/tree/master/a-lock",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://gitee.com/DemoMeng/better-skills/tree/master/a-lock"),a("OutboundLink")],1),s._v("\n具体实现")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1. 创建一张表 t_resource_lock ，这个表有 lock：上锁标识 、 time：上锁时间 等\n2. 需要执行具体业务的时候，就插入这个表一条数据表明这个业务数据被上锁了\n3. 执行完具体业务以后，再把该t_resource_lock 的数据删掉\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("存在的问题")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1. 过分依赖数据，若数据库服务挂掉，那么这个无法正常使用，且没有锁的失效时间，导致可能出现死锁的情况\n2. 因为操作是基于数据库的，一次请求如果过程中失败了，那么就要重新发起，没有重试机制！\n3. 这把锁是非重入锁，当A线程没有释放该锁的时候，无法重新获得该锁\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("乐观锁实现：\n"),a("ul",[a("li",[s._v("表新增一个version字段，更新的时候+1版本号，若比查出来的版本号大则可以更新，否则回滚。")]),s._v(" "),a("li",[s._v("适合并发不高的场景，需要设置重试机制")])])])]),s._v(" "),a("h2",{attrs:{id:"redis实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis实现分布式锁"}},[s._v("#")]),s._v(" Redis实现分布式锁")]),s._v(" "),a("p",[s._v("项目参考  "),a("a",{attrs:{href:"https://gitee.com/DemoMeng/better-skills/tree/master/a-lock",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://gitee.com/DemoMeng/better-skills/tree/master/a-lock"),a("OutboundLink")],1)]),s._v(" "),a("ul",[a("li",[a("ol",[a("li",[s._v("redisson")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("setnx + expire")])])])]),s._v(" "),a("h2",{attrs:{id:"zookeeper实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper实现分布式锁"}},[s._v("#")]),s._v(" Zookeeper实现分布式锁")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("链接：https://mp.weixin.qq.com/s/1-VX8exkDqZFTpbeull6mQ\n\n【1】分布式锁原理：\n    保证多个线程并发时，只有一个线程在同一时刻操作这个业务，或者说是方法，变量。\n\n【2】常规锁：\n    比如jvm中使用java.util.synchronized -- > 使用这个关键字，可以加载方法上或者是代码块上。\n    当然这种情况，是当前的项目只部署在一台服务器上，那么并发量是很差的。\n\n【3】解决常规锁的瓶颈问题：\n    常规锁存在并发的瓶颈问题。那么使用集群，分布式部署项目。多个服务节点来处理并发的请求。\n\n【4】分布式锁如何处理：\n    分布式锁需要独立于服务之外，不能在服务里面。 -- 分布式锁可以把整个集群就当作是一个应用一样去处理，那么也就需要这个锁，要独立于每一个服务之外，而不是在服务里面。\n\n【5】分布式锁实现：\n    a：数据库方式 --\x3e 数据库乐观锁实现\n    b: redis分布式锁  --\x3e jedis实现  ---\x3e Redission ---\x3e 还有Redis官方出品的 redLock\n    c: zookeeper分布式锁\n\n*******************Redis分布式锁**********************\nredis是单线程的，这里的单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])])])}),[],!1,null,null,null);e.default=n.exports}}]);