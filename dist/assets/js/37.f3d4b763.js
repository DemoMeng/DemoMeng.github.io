(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{427:function(s,n,a){"use strict";a.r(n);var t=a(54),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[s._v("#")]),s._v(" 分布式事务")]),s._v(" "),a("p",[s._v("https://blog.csdn.net/zzti_erlie/category_11350690.html")]),s._v(" "),a("h2",{attrs:{id:"分布式事务-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务-2"}},[s._v("#")]),s._v(" 分布式事务")]),s._v(" "),a("h3",{attrs:{id:"setata服务端-需要sql-seata-server-sql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setata服务端-需要sql-seata-server-sql"}},[s._v("#")]),s._v(" setata服务端: 需要sql ： seata-server.sql")]),s._v(" "),a("p",[s._v("https://github.com/seata/seata/blob/1.2.0/script/server/db/mysql.sql")]),s._v(" "),a("h3",{attrs:{id:"每个业务库都需要-undo-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#每个业务库都需要-undo-log"}},[s._v("#")]),s._v(" 每个业务库都需要 undo_log")]),s._v(" "),a("p",[s._v("https://github.com/seata/seata/blob/1.2.0/script/client/at/db/mysql.sql")]),s._v(" "),a("h3",{attrs:{id:"tc-、-tm-、-rm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tc-、-tm-、-rm"}},[s._v("#")]),s._v(" TC 、 TM 、 RM")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("TC : Transaction coordination： 事务协调器\n    维护全局和分支事务的状态，驱动全局事务提交或回滚。\nTM : Transaction Management: 事务管理器\n    定义全局事务的范围：开始全局事务、提交或回滚全局事务。\nRM : Resource Management : 资源管理器\n    管理分支事务处理的资源，与注册分支事务的状态、并且驱动分支事务提交或回滚\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h3",{attrs:{id:"_2pc-两阶段提交协议、也成为-xa-、-3pc-三阶段提交协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2pc-两阶段提交协议、也成为-xa-、-3pc-三阶段提交协议"}},[s._v("#")]),s._v(" 2PC （两阶段提交协议、也成为 XA） 、 3PC （三阶段提交协议）")]),s._v(" "),a("ul",[a("li",[s._v("一阶段事务提交（传统）数据库事务")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    1. 如果只有一个DB资源，那么在mysql中使用 begin、commit就能实现\n    2. 在spring中，一个注解 @Transactional ，如果发生了嵌套事务（一个方法中有另外一个方法操作资源！！），它的实现方式本质是通过 ThreadLocal 向下传递，若应用中有子线程相关的事物需要协调管理，它无法处理！！\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("2PC: Two Phase Commit Protocols 两阶段提交协议 ： 它实际上指的是两个分布式协调阶段")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    阶段1 事务管理器（单个）通知资源管理器（多个db）准备开始执行事务，并且锁住对应的资源（直到提交、回滚之后才会释放），当准备完毕，资源管理器回复通知给事务管理器，并且写入 undo / redo 日志 （undo 是记录操作之前，redo是操作时候的数据）\n    阶段2 若所有的资源都准备成功，事务管理器会要求所有的资源管理器进行提交操作，若有任意一资源管理器准备（第一阶段）失败，则事务管理器会要求所有的资源管理器回滚（第二阶段）\n    \n    \n    问题：\n        1. 单点故障问题 （SPOF：Single Point Of Failure）： 事务管理器可能故障，存在用于完成不了的事务。 \n        2. 阻塞问题： 阶段1中对资源是采用了锁的方式，可能出现锁无法释放的问题和竞争锁的问题。    \n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("ul",[a("li",[s._v("3PC: Three Phase Commit Protocols 三阶段提交协议")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    3pc 最显著的一个特点是加入了一个超时机制，\n    3pc 较于 2pc ，多了一个步骤就是 询问阶段（can commit） ，这个阶段是不会锁资源的，所以没有2pc的第一阶段的阻塞情况。\n\n    Can Commit: 询问是否可以提交，不会加锁\n    Pre Commit: 加入了超时机制，如果超时则认为失败\n    Do Commit: 若干preCommit 超时了，则就是需要回滚操作，不会因此而阻塞 \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h2",{attrs:{id:"分布式事务解决方案-xa、tcc、at-、saga"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务解决方案-xa、tcc、at-、saga"}},[s._v("#")]),s._v(" 分布式事务解决方案： XA、TCC、AT 、SAGA")]),s._v(" "),a("ul",[a("li",[s._v("XA： 2PC也叫做XA")])]),s._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"111",href:"XA流程.png"}},[a("img",{attrs:{src:"XA%E6%B5%81%E7%A8%8B.png",alt:"img.png"}})])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    流程： \n        1. 订单服务操作下的两个数据源，一个订单表，一个库存表\n        2. 订单服务通过嵌入的TM通知 订单RM 生成订单数据，同时通知 库存RM 扣减库存数据，此时两个RM都没有提交事务，所以订单和库存都是锁定的状态\n        3. TM收到两个RM的执行消息，只要有一方失败了，TM则通知RM回滚事务执行回滚，资源锁释放，若都成功，则TM通知所有RM提交事务，资源锁释放\n\n    问题： \n    \n        1. 两个阶段需要同时成功，否则同时锁定多个资源不释放，性能较差\n        2. 数据库需要支持 XA 协议\n        \n    解析：\n        整个事务流程涉及到三个角色： AP 、 RM 、 TM\n        其中AP指的是使用2PC的分布式事务的应用程序\n        RM是资源管理器，管理分支事务\n        TM是全局事务管理器，决定分支事务提交、回滚\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("ul",[a("li",[s._v("TCC : Try 、 Confirm 、 Cancel")])]),s._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"111",href:"TCC流程.png"}},[a("img",{attrs:{src:"TCC%E6%B5%81%E7%A8%8B.png",alt:"img.png"}})])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    TCC 主要分为三个操作\n        Try:  一阶段业务资源的检查和预留资源 \n        Confirm: 二阶段提交操作，所有的Try都成功了，则执行 Confirm的操作，Confirm真正执行业务，使用Try的预留的资源 \n        Cancel:  二阶段回滚操作，有一个Try失败了，则执行Cancel操作，Cancel释放Try的预留的资源\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("ul",[a("li",[s._v("AT:")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    1. Seata的AT模式，是Seata主推的模式，Seata的AT模式是无侵入的分布式事务模式。事务的1阶段和事务的2阶段均有Seata框架完成，\n       SQL解析作为阶段1，阶段2由框架自动生成提交、回滚操作\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("ul",[a("li",[s._v("AT: Seata-AT的工作机制：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    表结构：product\n    \n        Field\tType\t       Key\n        id\t    bigint(20)\t   PRI\n        name\tvarchar(100)\t\n        since\tvarchar(100)\t\n\n    若被全局事务管理的业务逻辑sql为：   update product set name = 'GTS' where name = 'TXC';\n    \n    ***** 阶段一 *****\n    \n    1. 解析sql，得到sql的类型（update）、表（product）、条件（name='TXC'）等信息\n    2. 根据a解析的sql，查询执行前镜像： select id, name, since from product where name = 'TXC';\n        得到数据：\n            id\tname\tsince\n            1\tTXC\t2014\n            \n    3. 执行业务sql，update的操作，即第1点的sql\n    4. 查询更新之后的数据：根据id查询\n        id\tname\tsince\n        1\tGTS\t    2014\n\n    5. 将插入之前的数据镜像，和插入之后的数据镜像都插入到undo_log中（回滚日志）        \n    6. 本地事务提交前，向TC注册分支事务，申请 product 表中的 id=1 的记录的 全局锁\n    7. 本地事务提交，业务数据更新，并且把之前 undo_log 的数据一并提交\n    8. 将本地事务提交的结果上报给TC\n    \n    \n    ***** 阶段二 - 提交 *****\n    \n    1. 收到 TC 分支事务提交的请求，提交本地事务，并且把提交结果上报给TC\n    2. 提交成功之后，批量删除undo_log的记录\n    \n    \n    \n    ***** 阶段二 - 回滚 *****\n    \n    1. 收到 TC 回滚的请求，开启一个本地事务，通过xid和BranchID 找到对应的 undo_log 记录\n    2. 拿到 undo_log 记录判断 前后的数据镜像是否一致，不一致则根据配置需要处理\n    3. 生成处理的sql ：把阶段1的更改的记录更改回前数据镜像，随后提交本地事务给 TC\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br")])]),a("ul",[a("li",[s._v("SAGA ： 长事务解决模式，Long Lived Transaction")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    1. 在分布式事务下，有多个参与者。依次执行各参与者的正向操作，若所有的操作均成功，则分布式事务提交。如果一个参与者的正向操作失败，则分布式事务回滚\n    \n    优点 ： \n        1. 并发度高，无锁，高性能\n        2. 开发量大，需要定义正向操作和补偿操作\n        3. 不能保证隔离型\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h2",{attrs:{id:"分布式事务解决方案之-本地消息表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务解决方案之-本地消息表"}},[s._v("#")]),s._v(" 分布式事务解决方案之 本地消息表")]),s._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"111",href:"分布式事务解决方案-本地消息表.png"}},[a("img",{attrs:{src:"%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png",alt:"img.png"}})])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    1. 订单服务执行保存订单入库、推送扣减库存消息给MQ（可以实时投递MQ也可以定时任务扫描消息记录表的未扣减状态进行投递消息），并且保存消息记录表记录（此时消息记录状态为未扣减），\n       因为订单入库和消息记录入库是同一个本地事务，所以不存在分布式事务。\n    2. 库存服务订阅了MQ的订单服务发送的消息，收到消息后执行扣减库存的操作（本地事务）\n    3. 库存服务扣减库存成功，随即投递消息给MQ，订单服务库存订阅此消息后，收到消息通知，修改消息记录表的状态。   \n    \n    \n    缺点：\n        1. 需要写入消息表，增加数据库的IO压力\n        2. 需要MQ第三方件协同，并且需要考证消息投递可靠，消费可靠性（消息一致性）\n        3. 过多的业务代码，耦合性加重\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h2",{attrs:{id:"seata实现2pc与传统2pc的差别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#seata实现2pc与传统2pc的差别"}},[s._v("#")]),s._v(" Seata实现2PC与传统2PC的差别")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    架构层次方面：\n        1. 传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，\n        2. Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用程序这一侧的。\n    两阶段提交方面：\n        1. 传统 2PC无论第二阶段的决议是 commit 还是 rollback ，事务性资源的锁都要保持到 Phase2 完成才释放。\n        2. Seata 的做法是在 Phase1 就将本地事务提交，这样就可以省去 Phase2 持锁的时间，整体提高效率。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h2",{attrs:{id:"seata分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#seata分布式事务"}},[s._v("#")]),s._v(" seata分布式事务")]),s._v(" "),a("ul",[a("li",[s._v("工作流程：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"SEATA分布式事务工作流程.png"}},[a("img",{attrs:{src:"SEATA%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png",alt:"img.png"}})])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("\n    1. TM 向 TC申请开启一个全局事务，TC创建一个创建一个全局事务，并且返回一个全局事务的xid，这个xid在微服务的链路中上下文传递\n    2. RM 向 TC 注册分支事务，分支事务的xid是上面那个全局事务的xid，因此可以通过xid获取到全局事务和分支事务\n    3. TM 向 TC 发起针对全局事务的xid为全局提交获取全局回滚操作\n    4. TC 协调 xid下的分支事务的提交或回滚操作\n    \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h2",{attrs:{id:"分布式事务产生的场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务产生的场景"}},[s._v("#")]),s._v(" 分布式事务产生的场景")]),s._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"111",href:"分布式事务产生的场景.png"}},[a("img",{attrs:{src:"%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9C%BA%E6%99%AF.png",alt:"img.png"}})])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    1. 微服务场景下，远程调用系统，跨JVM产生产生分布式事务\n       在单体应用中，一个业务操作需要调用多个模块完成的，此时的数据一致性是用本地事务来保证的\n       而在微服务调用中，产生了系统和系统之间调用，就必然会产生分布式事务的问题\n    \n    2. 单体访问多个数据库产生分布式事务\n    \n    3. 多个系统访问同一个数据库： 跨JVM\n    \n    本质： 都是因为产生了不同的数据库会话（session）操作数据库\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("h2",{attrs:{id:"分布式理论相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式理论相关"}},[s._v("#")]),s._v(" 分布式理论相关")]),s._v(" "),a("p",[s._v("在单个数据库的性能存在瓶颈的时候，我们可能会对数据库进行分库，数据库多个库存在不同的服务器上，\n这个时候单机数据库的事务ACID不适应这种情况了，而且在ACID事务下集群实例想要保证各个应用的数据统一也比较难达到。\n这个时候需要引入一个新的理论规则来应对上述情况，这个理论就是CAP原则（定理）")]),s._v(" "),a("h3",{attrs:{id:"cap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cap"}},[s._v("#")]),s._v(" CAP：")]),s._v(" "),a("ul",[a("li",[s._v("CAP：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    C： Consistency ： 一致性\n    A： Available ：可用性\n    P： Partition Tolerance： 分区容忍性\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("现举例来理解 CAP 理论\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"CAP-1.png"}},[a("img",{attrs:{src:"CAP-1.png",alt:"img.png"}})])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    场景： \n        1. 订单服务 新增、修改、删除的请求打到mysql主库\n        3. 从库异步请求主库根据主库binlog日志异步同步数据到从库\n        2. 订单服务查询最新的订单信息， 查询 的请求打到mysql从库\n        \n    \n    Consistency: 一致性\n        目标：\n            如上的场景中下，订单的读、写满足的一致性就需要： 订单写入主库成功，订单查询从库能取出最新的信息，若失败，则无法查询到最新的数据\n        \n        实现一致性： \n            1. 写入主库成功之后，需要同步到从库\n            2. 在同步期间，需要锁定从库，因为数据没有同步完成，等同步完成后释放锁。这样避免了同步期间（耗时长），读取的数据是不是订单系统插入主库最新的数据\n    \n    Available: 可用性\n    \n        目标： \n            1. 订单写入主库成功响应\n            2. 订单查询从库成功响应，并且不会存在阻塞的情况，立即响应，不管数据是否最新！ \n        \n        实现可用性：\n            1. 主库同步数据到从库\n            2. 从库在同步期间不锁定，立即响应数据给订单服务。\n            \n    Partition Tolerance： 分区容忍性\n    \n        目标：\n            1. 从库在同步主库的binlog中若失败，不会影响读的操作，也不会影响主库写的操作\n            2. 其中一个节点down后，不会影响另外一个节点提供服务\n            \n        实现：\n            1. 从库同步binlog的方式采用异步更新，\n            2. 一主多从（冷备），双主多从（热备）的模式\n    \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br")])]),a("ul",[a("li",[s._v("CAP理论在实际中的满足情况：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    前提： \n        在有P的情况下Consitency和 Available是不能共存的！因为保证一致性的情况下，就必须要加上锁，加锁之后就会有响应不及时，导致 Available 无法满足 ！！\n        也就是说，在mysql集群模式下，C和A是无法共存的！若mysql是单机的情况CA可以共存，但是存在mysql单点故障的情况 ！！ \n    \n    常见搭配：\n    \n        CP： 一致性，分区容忍性 均满足，：要求强一致性，比如zookeeper追求的强一致性，比如跨行转账，一次转账要求双方银行都完成了整个事务才算完成\n        \n        AP： 可用新，分区容忍性 均满足 ： 常用，一些业务场景比如：订单退款，今日退款成功，明日账户到账，只要用户可以接受在一定的时间内到账即可。\n        \n        CA： 一致性，可用性 均满足 ： 即mysql单点统一提供读写 \n    \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("h3",{attrs:{id:"base-理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#base-理论"}},[s._v("#")]),s._v(" BASE 理论：")]),s._v(" "),a("p",[s._v("在分布式系统中，我们需要保证系统的可用性，这个的重要性会比数据一致性要高。\n分布式系统需要实现高可用性，需要保证系统满足BASE理论")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("Base Available： 出现故障后，保证核心系统可用，不影响核心的系统可以故障\nSoft status ： 数据的中间的中间状态，比如订单退款中，但是这个数据的最终状态是成功！\nEventually ：  会有一定的延迟，担数据最终一致！\n")])])]),a("p",[s._v("BASE理论是对CAP中一致性和可用性的中和权衡的结果，实际上并无法做到强一致性，但每个应用的业务特点，采用属于系统合适的规则最终达到一致性。")]),s._v(" "),a("h2",{attrs:{id:"数据库事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库事务"}},[s._v("#")]),s._v(" 数据库事务")]),s._v(" "),a("p",[s._v("事务本质上来说是多个操作，其中要么所有操作都成功，要么全部失败！")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    特性： ACID\n        A: Atomicity ：原子性：   整个事务是不可分割的部分，要么全部成功，否则全部失败。即执行发生异常sql的之前的sql也需要回滚，不管其已经成功 ！！\n        C: Consistency：一致性：  数据的完整性和业务一致性。比如银行转账的时候，不管如何转账，总额是不变的。\n        I: Isolation：隔离性：    A事务不会影响B事务\n        D: Durabilily ：持久性：  所做的修改最终都会落到数据库上，不会因为系统故障导致数据丢失\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h2",{attrs:{id:"并发事务导致的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发事务导致的问题"}},[s._v("#")]),s._v(" 并发事务导致的问题")]),s._v(" "),a("p",[s._v("多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("名词解释：\n      不可重复读： 两次读取数据在中途中被修改。比如 A事务多次读了同一个数据，但是A事务还未结束，此时B事务也访问该数据，在A事务中的读该数据之间，B事务执行并且提交了，这就导致A事务里的在B事务提交之后读出来的数据和一开始读的数据不一致​。​\n                 存在的隔离机制为：读已提交、读未提交，解决办法：使用可重复读隔离机制。\n      脏读：读到了未提交的数据，也就是本应该提交后才能的读取的数据，在未提交就被提前读取了。\n           比如：A事务正在对数据进行修改，但是还未完成其事务，未提交变更后的数据，但是此时B事务也访问到了该数据，读取出来的数据是A还未提交前的数据（不是A事务修改后最新的），所以此时B事务读取到了“脏数据”，因此B对该脏数据的操作也可能是不正确的​。​\n           存在的隔离机制为读未提交，解决办法：使用读已提交的隔离机制。\n      幻读：在同一个事务内，同一条sql语句在不同时间段内查询出来的数据不一样。 解决办法：innoDB引擎的间隙锁。\n           当MySQL InnoDB引擎在一行行扫描的过程中，不仅会给行加上行锁，还会给行的两边的空隙也加上间隙锁。由于间隙锁（gap lock）仍在存在一些问题，可能会降低并发度和仍然可能导致死锁。\n           因此，MySQL InnoDB为间隙锁引入了一个补充：next-key lock。所谓next-key lock，它是间隙锁和行锁的合体，每个next-key lock都是前开后闭区间，如 (0,5]。\n           间隙锁都是开区间，如 (0,5)。next-key lock帮助MySQL在默认隔离级别下解决了幻读问题，因此它也是MySQL加锁的基本单位。\n      \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("1.隔离机制可能会产生的问题：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"隔离机制可能会产生的问题.png"}},[a("img",{attrs:{src:"%E9%9A%94%E7%A6%BB%E6%9C%BA%E5%88%B6%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98.png",alt:"img.png"}})])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("      读未提交： 幻读、脏读、不可重复读 \n      读已提交： 幻读、不可重复读\n      可重复读： 幻读\n      可串连化：\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("2.SQL的隔离机制：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("   \n      读已提交：SQL Server和Oracle默认隔离机制。 （不可重复读）\n              设置 ：  set transaction_isolation='read-committed';    \n      \n              事务A                                                         事务B\n            1 begin                                                       \n            2                                                              select name from user where id = 1    => 结果为 '李四'\n            3 update user set name = '张三' where id = 1   \n            4                                                              select name from user where id = 1    => 结果为'李四' \n            5 commit\n            6                                                              select name from user where id = 1    => 结果为'张三' （事务B只能读取到事务A已经提交的数据）\n  \n      读未提交：可以读取到未提交的数据。\n              极少使用该机制，可能出现脏读，幻读  \n              设置 ： set transaction_isolation='read-uncommitted';\n      \n              事务A                                                         事务B\n            1 begin                                                       \n            2                                                              select name from user where id = 1    => 结果为 '李四'\n            3 update user set name = '张三' where id = 1   \n            4                                                              select name from user where id = 1    => 结果为'张三' (这sql能读取到事务A的未提交的数据'张三')\n            5 commit\n            6                                                              select name from user where id = 1    => 结果为'张三'  \n      可重复读：Mysql默认隔离机制。\n              在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。（参考images/可重复读.png）\n              可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。\n              \n              提问：为什么上了写锁（写操作），别的事务还可以读操作？\n              因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。\n                              \n      可串行化：\n             读读操作不会阻塞\n             读写操作会阻塞写操作\n             写读操作会阻塞读操作\n             写写操作会阻塞写（后）操作\n             \n      不可重复读和幻读的区别：\n        不可重复读注重的是修改，幻读注重的是新增、删除\n        不可重复读：A事务中查询张三的银行卡余额为300块，此时A事务操作还未结束，B事务执行了公司发工资给张三增加了200块，此时张三银行卡的为500块，B事务结束并提交。此时A事务后续操作再读张三的银行卡余额发现张三此时有500块\n        幻读：工资表中工资大于3000的总共有4人。此时事务A读取到了工资大于3000的有4个人，事务B插入了一条工资大于3000的数据到工资表中，此时事务A再读会发现有5个人工资大于3000       \n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br")])]),a("p",[s._v("3.设置隔离机制：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("      方式1：通过set命令\n          SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;\n              其中level有4种值：\n              level: {\n                   REPEATABLE READ\n                 | READ COMMITTED\n                 | READ UNCOMMITTED\n                 | SERIALIZABLE\n              }\n              \n关键词：GLOBAL\nSET GLOBAL TRANSACTION ISOLATION LEVEL level;\n    * 只对执行完该语句之后产生的会话起作用\n    * 当前已经存在的会话无效\n关键词：SESSION\nSET SESSION TRANSACTION ISOLATION LEVEL level;\n    * 对当前会话的所有后续的事务有效\n    * 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务\n    * 如果在事务之间执行，则对后续的事务有效。\n无关键词\nSET TRANSACTION ISOLATION LEVEL level;\n    * 只对当前会话中下一个即将开启的事务有效\n    * 下一个事务执行完后，后续事务将恢复到之前的隔离级别\n    * 该语句不能在已经开启的事务中间执行，会报错的\n              \n      方式2：通过服务启动项命令\n          可以修改启动参数transaction-isolation的值\n          比方说我们在启动服务器时指定了--transaction-isolation=READ UNCOMMITTED，那么事务的默认隔离级别就从原来的REPEATABLE READ变成了READ UNCOMMITTED。\n\n\n        \n    1. 数据库写入数据的时候都是先写入日志的，在执行事务的时候，会先写入redo日志，然后再开始操作数据。数据库操作之前首先日志文件会写入磁盘，若写入中途出现\n       断电断网的操作，数据库重新启动之后，会根据当前的数据情况进行redo和undo的操作。这样用于保证数据的一致性。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br")])]),a("ul",[a("li",[a("p",[s._v("读已提交：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"读已提交.png"}},[a("img",{attrs:{src:"%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4.png",alt:"img.png"}})]),s._v(" "),a("a",{attrs:{"data-fancybox":"",title:"111",href:"读已提交1.png"}},[a("img",{attrs:{src:"%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A41.png",alt:"img.png"}})])])]),s._v(" "),a("li",[a("p",[s._v("读未提交：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"读未提交.png"}},[a("img",{attrs:{src:"%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4.png",alt:"img.png"}})])])]),s._v(" "),a("li",[a("p",[s._v("可重复读：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"可重复读.png"}},[a("img",{attrs:{src:"%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png",alt:"img.png"}})])])]),s._v(" "),a("li",[a("p",[s._v("可序列化\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"可序列化.png"}},[a("img",{attrs:{src:"%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96.png",alt:"img.png"}})])])]),s._v(" "),a("li",[a("p",[s._v("可序列化-读读操作：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"可串行化-读读操作.png"}},[a("img",{attrs:{src:"%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96-%E8%AF%BB%E8%AF%BB%E6%93%8D%E4%BD%9C.png",alt:"img.png"}})])])]),s._v(" "),a("li",[a("p",[s._v("可序列化-读写操作：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"可串行化-读写操作.png"}},[a("img",{attrs:{src:"%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96-%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C.png",alt:"img.png"}})])])]),s._v(" "),a("li",[a("p",[s._v("可序列化-写读操作：\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"可串行化-写读操作.png"}},[a("img",{attrs:{src:"%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96-%E5%86%99%E8%AF%BB%E6%93%8D%E4%BD%9C.png",alt:"img.png"}})])])]),s._v(" "),a("li",[a("p",[s._v("可序列化-写写操作\n"),a("a",{attrs:{"data-fancybox":"",title:"111",href:"可串行化-写写操作.png"}},[a("img",{attrs:{src:"%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96-%E5%86%99%E5%86%99%E6%93%8D%E4%BD%9C.png",alt:"img.png"}})])])])]),s._v(" "),a("h2",{attrs:{id:"数据库锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库锁"}},[s._v("#")]),s._v(" 数据库锁")]),s._v(" "),a("p",[s._v("当数据库有并发事务的时候，可能会产生数据不一致，这个时候需要用锁机制来进行协调和计算。")]),s._v(" "),a("ul",[a("li",[s._v("InnoDB与MYISAM的最大不同有两点：\nInnoDB支持事务\nInnoDB支持行级锁\nMYISAM： 采用表级锁\nInnoDB:  支持表级锁和行级锁，默认是行级锁")])]),s._v(" "),a("p",[s._v("1.性能上划分： 悲观锁、乐观锁")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    悲观锁： 假设会发生并发冲突，（考虑到存在并且肯跟会发生的并发冲突下）屏蔽一切可能违反数据完整性的操作，在查询完数据的时候就把事务锁起来，知道事务提交。\n           实现方式 ： 数据库中的锁机制 （读锁、写锁）\n   \n    乐观锁： 假设不会发生并发冲突，只在提交的操作检查是否违反了数据完整性，在修改数据的时候把事务锁起来，通过version方式来进行处理\n           实现方式 ： 版本号方式，或者CAS算法实现\n\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("2.操作类型划分：（读锁和写锁都是悲观锁）")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    读锁（共享锁、S锁(Shared) ）： 针对同一份数据，多个读操作可以同时进行而不会互相影响。\n    写锁（排他锁、X锁(eXclusive) ）：当前写操作没有完成前，它会阻断其他写锁和读锁。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("3.数据操作的粒度：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("        表级锁： （颗粒度最大的锁）对整个表加锁，实现简单，资源消耗少，别大部分Mysql引擎支持（MYISAM 和 InnoDB均支持 表级锁），表级锁定氛围共享锁（读锁）和拍他锁（写锁）\n                特点： 开销小，加锁快，不会出现思索，锁定颗粒度大，发出锁冲突的概率最高，并发度最低。\n        行级锁： （颗粒度最小的锁）行锁每次操作锁住一行数据，一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞 （这个看具体字段，id/索引字段不会阻塞，否则会阻塞）。\n                特点： 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。\n                \n        页级锁： 颗粒度介于行级锁和表级锁之间的一种锁，表级锁加锁速度快，但是冲突多，行级锁加锁速度慢。所以折中的页级锁，一次锁定相邻的一组记录\n                特点： 开销和加锁速度介于表锁和行锁之间，会出现死锁，加锁粒度介于表锁和行锁之间，并发度也处于二者之间\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);