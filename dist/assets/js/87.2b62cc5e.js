(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{477:function(s,a,n){"use strict";n.r(a);var e=n(54),t=Object(e.a)({},(function(){var s=this,a=s.$createElement,n=s._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("p",[s._v("#rabbitmq")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("https://gitee.com/DemoMeng/better-rabbit-mq.git\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("h2",{attrs:{id:"消息队列定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#消息队列定义"}},[s._v("#")]),s._v(" 消息队列定义")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("使用队列来通信的组件，本质就是一个转发器，包含发消息、存消息、消费消息的过程。\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br")])]),n("h2",{attrs:{id:"消息队列应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#消息队列应用场景"}},[s._v("#")]),s._v(" 消息队列应用场景")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\n1 应用解耦 ： \n      用户注册动作，调用用户系统，注册成功后，发送短信（通知系统）、增加积分（积分系统）、邀请分销（分销系统）等，均可使用消息队列来做异步操作。\n      若其中一个系统出现异常则无法完成注册流程。\n2 流量削峰\n      秒杀场景下只允许队列的部分用户进行秒杀，避免过多请求打到应用。\n3 异步处理   \n      用户注册后，执行发送短信和发送邮箱的操作（耗时操作），如果一起串行操作则回比较耗时。\n         \n4 消息通信\n      消息队列内置了高效的通信机制，可用于消息通讯。如实现点对点消息队列、聊天室等。\n5 远程调用\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br")])]),n("h2",{attrs:{id:"如何保证消息有序执行"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息有序执行"}},[s._v("#")]),s._v(" 如何保证消息有序执行")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("h2",{attrs:{id:"内部结构及工作流程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内部结构及工作流程"}},[s._v("#")]),s._v(" 内部结构及工作流程：")]),s._v(" "),n("p",[n("a",{attrs:{"data-fancybox":"",title:"111",href:"rabbitmq结构及工作流程.png"}},[n("img",{attrs:{src:"rabbitmq%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png",alt:"img.png"}})])]),s._v(" "),n("h2",{attrs:{id:"功能介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#功能介绍"}},[s._v("#")]),s._v(" 功能介绍")]),s._v(" "),n("ul",[n("li",[s._v("每个VirtualHost相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的，exchange、queue、message不能互通")]),s._v(" "),n("li",[s._v("RabbitMQ功能模型\n"),n("a",{attrs:{"data-fancybox":"",title:"111",href:"rabbitMQ功能模型.png"}},[n("img",{attrs:{src:"rabbitMQ%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B.png",alt:"img.png"}})])])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v(" Broker:  就是RabbitMQ服务实体\n VHost:   vhost 可以理解为虚拟 broker，即 mini-RabbitMQ server。其内部均含有独立的 queue、exchange 和 binding 等\n          但最最重要的是，其拥有独立的权限系统，可以做到 vhost 范围的用户控制。当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段（一个典型的例子就是不同的应用可以跑在不同的 vhost 中）。   \n Exchange: 消息交换机，它主要作用是消息按照什么规则路由到某个队列\n RouteKey: 消息路由规则，exchange根据这个规则投递消息\n Queue:  消息队列\n Binding: 它的作用就是把 exchange 和 queue 按照路由规则绑定起来\n Producer: 消息生产者\n Consumer: 消息消费者\n Channel:  消息通道，在客户端的每个连接里可以建立多个channel，每个channel代表一个会话任务 \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("h2",{attrs:{id:"rabbitmq的工作模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq的工作模式"}},[s._v("#")]),s._v(" RabbitMQ的工作模式：")]),s._v(" "),n("p",[n("a",{attrs:{"data-fancybox":"",title:"111",href:"rabbitMQ工作模式.png"}},[n("img",{attrs:{src:"rabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png",alt:"img.png"}})])]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("1. Simple简单模式： \n        定义： 生产者生产出消息，放入消息队列，消费者监听队列，消费消息。消费完成之后删除队列中的消息。 \n        问题： a. 存在安全隐患，当消费者消费完后，需要发送ack确认给消息队列，否则队列中消息会堆积导致内存溢出。\n              b. 生产者和消费者要一一对应，如果有多个消费者则无法实现。\n          \n2. Work工作模式：\n        定义： 生产者把消息放入队列，消费者是多个场景下，其中MQ给消费者推送的消息主要按照： 轮询模式、公平分发\n        轮询模式： MQ无法知道消费者的消费能力和服务器能力，所以是每个消费者轮询算法来。\n        公平分发： 消费者消费完一次就向通知MQ，消息已经消费完成，MQ就会再发送消息给消费者消费。\n        \n3. 发布订阅模式 fanout publish/subscribe ： \n        定义： 类似公众号！只需要交换机和队列绑定，生产者把消息发送给交换机后MQ就会把该消息发送给所有绑定了该交换机的队列消费者    \n        含义： \n              a. 一个生产者多个消费者\n              b. 每一个消费者都有一个自己的队列\n              c. 生产者没有把消息直接发送到队列而是发送到了交换机转化器(exchange)。\n              d. 每一个队列都要绑定到交换机上。\n              e. 生产者发送的消息经过交换机到达队列，从而实现一个消息被多个消费者消费。\n              \n4. direct routing:路由模式：\n        定义： 需要指定 route key，生产者生产消息需要制定route key，队列的时候也要指定 route key，消息指定投递exchange然后交换机投递给route key一致的队列，供绑定队列的消费者消费。\n        缺点： route key需要生产消息和队列一致才能让exchange投递都指定的队列中。无法实现模糊匹配。\n        \n5. topic主题模式：\n        定义： 生产者携带route key发送给交换机，交换机会根据模糊匹配的规则发送给带 route key 模糊规则的队列。\n        模糊规则： \n                  a: # 表示匹配 >=1个字符\n                  b: * 表示匹配1个字符  \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br")])]),n("h2",{attrs:{id:"exchange交换机"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exchange交换机"}},[s._v("#")]),s._v(" Exchange交换机")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("1. Exchange常见的集中交换机：\n  fanout：发布订阅交换机：exchange收到消息，会广播给给所有绑定了的队列\n  direct：直连接交换机：route key 完全匹配，exhcange发送给完全匹配的队列\n  topic： 主题交换机： route key根据通配符，exhcange发给通配route key的队列\n  headers： headers交换机是根据发送的消息内容中的headers属性进行路由的。在绑定Queue与Exchange时指定一组键值对；\n            当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；\n            如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。此外 headers 交换器和 direct 交换器完全一致，但性能差很多。\n  durability： \n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("h2",{attrs:{id:"ack确认机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ack确认机制"}},[s._v("#")]),s._v(" ACK确认机制")]),s._v(" "),n("p",[s._v("目的： 确保消息不会丢失！！")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("- 0. 事务机制 确认： Transaction  \n     发送消息之前，开启事务channel.txSelect，然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()），如果发送成功则提交事务 channel.txCommit()\n     事务卡顿会导致后面无法发送，官方说加入事务机制MQ会降速250倍。    \n\n\n- 1.消息发送 确认：确认生产者将消息发送给交换器、交换器传递（绑定）给队列过程是否成功投递，\n    步骤：一是确认是否到达交换器，\n         二是确认是否到达队列，若失败则是exchange - routing key - queue绑定错误！！  \n    具体： \n        1. ConfirmCallback 回调方法\n            消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，也就是只确认是否正确到达 Exchange 中。\n            \n            \n        2. ReturnCallback 回调方法，\n            交换器路由不到队列时触发回调，该方法可以不使用，因为交换器和队列是在代码里绑定的，如果消息成功投递到 Broker 后在绑定队列失败，除非你代码写错了   \n  \n- 2.消费接收 确认：确认消费者是否成功消费了队列中的消息，\n   发生在监听队列的消费者处理业务失败，比如业务数据有误等，这种情况就需要手动处理，比如重新发送或者丢弃。\n   \n   - RabbitMQ默认的ack是自动确认的方式（auto），自动确认会在消息到达消费者后立即确认，存在丢失的可能性，如果消费端抛出异常消息就会丢失掉（若不手动处理）\n       a. 消费端确认模式：(配置文件中配置)\n          AcknowledgeMode.AUTO ：根据情况确认\n          AcknowledgeMode.NONE :  自动确认\n          AcknowledgeMode.MANUAL ： 手动确认\n       b. 代码手动调用channel方法确认：\n          channel.basicAck(long deliveryTag, boolean multiple); 用于确认当前消息。\n          channel.basicNack(long deliveryTag, boolean multiple, boolean requeue); 用于否定当前消息（注意：这是AMQP 0-9-1的RabbitMQ扩展） 。\n          channel.basicReject(long deliveryTag, boolean multiple); 用于拒绝当前消息。\n          deliveryTag：\n              唯一标识 ID，当一个消费者向 RabbitMQ 注册后，会建立起一个 Channel ，RabbitMQ 会用 basic.deliver 方法向消费者推送消息，\n              这个方法携带了一个 delivery tag， 它代表了 RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID，是一个单调递增的正整数，delivery tag 的范围仅限于 Channel。\n          multiple：是否批处理，当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息\n          requeue: 如果 requeue 参数设置为 true，则 RabbitMQ 会重新将这条消息存入队列，以便发送给下一个订阅的消费者； 如果 requeue 参数设置为 false，则 RabbitMQ 立即会还把消息从队列中移除，而不会把它发送给新的消费者\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br"),n("span",{staticClass:"line-number"},[s._v("11")]),n("br"),n("span",{staticClass:"line-number"},[s._v("12")]),n("br"),n("span",{staticClass:"line-number"},[s._v("13")]),n("br"),n("span",{staticClass:"line-number"},[s._v("14")]),n("br"),n("span",{staticClass:"line-number"},[s._v("15")]),n("br"),n("span",{staticClass:"line-number"},[s._v("16")]),n("br"),n("span",{staticClass:"line-number"},[s._v("17")]),n("br"),n("span",{staticClass:"line-number"},[s._v("18")]),n("br"),n("span",{staticClass:"line-number"},[s._v("19")]),n("br"),n("span",{staticClass:"line-number"},[s._v("20")]),n("br"),n("span",{staticClass:"line-number"},[s._v("21")]),n("br"),n("span",{staticClass:"line-number"},[s._v("22")]),n("br"),n("span",{staticClass:"line-number"},[s._v("23")]),n("br"),n("span",{staticClass:"line-number"},[s._v("24")]),n("br"),n("span",{staticClass:"line-number"},[s._v("25")]),n("br"),n("span",{staticClass:"line-number"},[s._v("26")]),n("br"),n("span",{staticClass:"line-number"},[s._v("27")]),n("br"),n("span",{staticClass:"line-number"},[s._v("28")]),n("br"),n("span",{staticClass:"line-number"},[s._v("29")]),n("br"),n("span",{staticClass:"line-number"},[s._v("30")]),n("br"),n("span",{staticClass:"line-number"},[s._v("31")]),n("br"),n("span",{staticClass:"line-number"},[s._v("32")]),n("br"),n("span",{staticClass:"line-number"},[s._v("33")]),n("br")])]),n("h2",{attrs:{id:"消息列表消息丢失"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#消息列表消息丢失"}},[s._v("#")]),s._v(" 消息列表消息丢失")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("    1. 处理消息列表丢失的情况一般是开启消息队列持久化配置！！ \n    配置： \n        1. 在创建队列的时候，durable = true, 将 queue 的持久化设置为 true，则代表是一个持久的队列 。 参考 exchange-routing-key的config代码 \n        2. 发送消息的时候，设置消息持久化  deliveryMode = 2 。 参考延迟队列demo中MessagePostProcessor的 发送消息代码！\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br")])]),n("h2",{attrs:{id:"死信"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#死信"}},[s._v("#")]),s._v(" 死信")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("死信队列\n     1 死信队列：DLX ， dead-letter-exchange\n     2 死信： 当一个消息变成死信后，会被published到另外一个队列就是DLX死信队列\n\n死信：\n    1 消息被拒绝 channel.basicReject()、channel.basicNack() 并且requeue=false\n    2 当前队列中的消息数量已经超过最大长度\n    3 当前消息在队列中的存活时间已经超过了预先设置的TTL(Time To Live)时间\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("h2",{attrs:{id:"日志追踪"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#日志追踪"}},[s._v("#")]),s._v(" 日志追踪")]),s._v(" "),n("ol",[n("li",[s._v("进入rabbitmq执行 rabbitmq-plugins enable rabbitmq_tracing 开启日志追踪插件功能")])]),s._v(" "),n("p",[n("a",{attrs:{"data-fancybox":"",title:"111",href:"rabbitmq开启插件.png"}},[n("img",{attrs:{src:"rabbitmq%E5%BC%80%E5%90%AF%E6%8F%92%E4%BB%B6.png",alt:"img.png"}})])]),s._v(" "),n("h2",{attrs:{id:"消息投递保证"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#消息投递保证"}},[s._v("#")]),s._v(" 消息投递保证：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("    消息投递保证不可能100%都投递/消费成功，需要消息补偿机制：\n\n    1. 消息成功投递，消费者成功接收：生产者->交换器、路由->队列\n    2. 交换机、路由、队列可靠性，设置他们持久化\n    3. 消息成功被消费，消费方确认Ack机制\n    4. 消息补偿机制：\n        a. 生产者投递消息给mq后，同时持久化消息信数据并且初始化状态，在 ConfirmCallback 中消息投递成功后更新消息信数据状态 （考虑 ReturnCallback交换机经路由传递给队列true/false）！\n        b. 分布式定时任务5分钟扫描DB获取未成功投递的消息信数据，并且重新投递给mq。\n            存在mq挂掉，交换机路由队列误删的情况多次投递也无法成功，可以设置重新投递规则即重试机制，超过重试机制次数还是失败，更新消息信数据状态为指定值，留给后期人工去处理\n\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br"),n("span",{staticClass:"line-number"},[s._v("10")]),n("br")])]),n("p",[s._v("#消息幂等性：")]),s._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("请求高峰情况下，生产者成功发送了消息并且消费者已成功收到消息且消费成功，这个时候网络终端等情况导致消费端Ack未能返回给Mq（生产者）导致消息下一次会被重新消费\n\n解决方案：\n       a. redis生成唯一标识\n       b. uuid + 业务id \n    \n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br")])])])}),[],!1,null,null,null);a.default=t.exports}}]);