(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{463:function(s,e,a){"use strict";a.r(e);var n=a(54),t=Object(n.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"项目地址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目地址"}},[s._v("#")]),s._v(" 项目地址")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://gitee.com/DemoMeng/better-redis.git",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://gitee.com/DemoMeng/better-redis.git"),a("OutboundLink")],1)]),s._v(" "),a("h2",{attrs:{id:"是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#是什么"}},[s._v("#")]),s._v(" 是什么")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1.单线程的kv内存数据库\n2.支持持久化\n3.nosql，非关系型数据库 （mysql 关系型数据库）\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h2",{attrs:{id:"redis为什么那么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis为什么那么快"}},[s._v("#")]),s._v(" redis为什么那么快")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("https://mp.weixin.qq.com/s/TRc0w279qY3DSTbCOlX3NA\n\nRedis Server是多线程的，只是它的请求处理整个流程是单线程处理的，平时说的Redis单线程快是指它的请求处理过程非常地快！\nRedis的性能非常之高，每秒可以承受10W+的QPS，它如此优秀的性能主要取决于以下几个方面：\n    纯内存操作： KV内存数据库，所有数据在内存中操作，key的查找为0（1）复杂度\n    使用IO多路复用技术\n    非CPU密集型任务\n    单线程的优势：避免多线程切换上线文带来的资源浪费\n    \n多线程优化：比如AOF文件重写（持久化的方式之一）都是在另外一个线程中执行的。\n\nRedis不同版本之间采用的线程模型是不一样的，在Redis4.0版本之前使用的是单线程模型，在4.0版本之后增加了多线程的支持。\n在4.0之前虽然我们说Redis是单线程，也只是说它的网络I/O线程以及Set 和 Get操作是由一个线程完成的。但是Redis的持久化、集群同步还是使用其他线程来完成。\n\n4.0之后添加了多线程的支持，主要是体现在大数据的异步删除功能上，例如 unlink key、flushdb async、flushall async 等\n\n在4.0之后，引入了新的命令和添加了新的机制，目的是解决释放大内存数据的时候造成内存阻塞的问题：\n在删除大的key，释放内存的操作往往是比较耗时的，redis采用的异步释放，把释放操作放到另外一个线程异步去执行，这样既不影响主线程的执行，又提高了性能。\n          命令：  \n                lazyfree\n                unlink\n                flushall async\n                flushdb async\n          机制：\n                lazyfree-lazy-eviction\n                lazyfree-lazy-expire\n                \nRedis的缺点：\n    1.单线程操作如果耗时久的话，造成线程阻塞，其他的请求也无法进来处理。Redis变慢或者长时间阻塞的问题，基本就是Redis处理单线程的原因。\n    \n    所以需要避免这种问题出现：\n        a.使用时间复杂度高的方式获取数据，例如：查找到xxx年xx月xx日的数据，这样复杂度就非常的高。尽量使用简单的K获取数据。\n        b.大量数据在同一个时间统一过期，导致Redis淘汰压力过大。可以使用防抖key，随机时间过期，避免大量的key的过期时间都一样。\n        c.一次性获取大量的数据\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br")])]),a("h2",{attrs:{id:"redis的io复用技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis的io复用技术"}},[s._v("#")]),s._v(" redis的IO复用技术")]),s._v(" "),a("p",[s._v("Redis 的 I/O 多路复用模式使用的是 「Reactor 设置模式」的方式来实现，如下图：\n"),a("a",{attrs:{"data-fancybox":"",title:"Redis的IO复用技术",href:"Redis的IO复用技术.png"}},[a("img",{attrs:{src:"Redis%E7%9A%84IO%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF.png",alt:"img.png"}})]),s._v("\n文件描述符：File Description\nLinux 系统中，把一切都看作是文件，当进程打开现有文件和创建新的文件，内核向进程返回一个文件描述符。\n文件描述符可以理解为文件索引，要操作文件的时候，直接根据这个文件描述符就能找到文件。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("为什么：\n    因为redis都是跑在单线程中，所有get和set都是等待客户端的时候均为阻塞的，所以这种情况下导致某个client客户端的操作长时间未结束，会阻塞别的客户端的操作。\n\nIO复用就是为了解决单线程的服务端能够同时处理多个客户端的事件，Redis采用了IO复用的机制。\n\n流程：\n    1. 一个 Socket 客户端和服务端连接时，会生成对应的一个套接字描述符（套接字描述符是文件描述符的一种），每一个 Socket 网络连接都对应一个套接字描述符号。\n    2. 多个客户端和服务端连接时候，Redis使用 IO复程序，将客户端的文件描述符注册到一个监听队列中，当客户端执行 read 、 write等操作命令时，\n    IO复用程序会将命令封装程一个事件并且绑定到对应的FD中\n    \n    3. 文件事件处理器使用 IO复用模块同时监听多个 FD 的读写情况，当 Accept 、 Read 、 Write 、Close 文件事件产生时，文件事件处理器就会回调FD及绑定的事件，处理对应的命令\n    4. 整个文件事件处理器在单线程上运行的，但是通过IO多路复用模块的引入，实现了同时对多个FD进行读写的监听，当一个client有读写的请求时，文件事件处理器会立即执行，从而不会出现IO阻塞的效果。\n    \n    \nRedis IO复用程序以 epoll函数为例：\n    多个客户端连接服务端时，Redis 会将客户端 socket 对应的 fd 注册进 epoll，然后 epoll 同时监听多个文件描述符(FD)是否有数据到来，如果有数据来了就通知事件处理器赶紧处理，这样就不会存在服务端一直等待某个客户端给数据的情形。\n\nI/O多路复用程序函数有 select、poll、epoll、kqueue\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br")])]),a("h2",{attrs:{id:"redis持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[s._v("#")]),s._v(" redis持久化")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1.RDB(Redis Database) : 定时把内存中的数据同步到磁盘，利用文件的形式。\n    我们可以通过redis.conf中的save配置或执行bgsave命令让Redis在本地生成RDB快照文件，这个RDB文件包含了整个实例接近完整的数据内容。\n    :RDB采用的是内存快照的方式，它记录的是某一时刻的数据，而不是操作，所以采用RDB方法做故障恢复时只需要直接把RDB文件读入内存即可，实现快速恢复。\n    \n    RDB生成快照会阻塞线程吗 ？\n     1. save: 主线程执行生成快照的命令。\n     2. bgsave: 会创建一个子线程用于写入RDB的快照文件，避免对主线程阻塞，这也是Redis的RDB的默认配置。\n    \n    \n2.AOF(Append Only File) : 把redis的日志文件读取出来，针对增删改的redis操作持久化到磁盘中。查询不会。\n    :AOF采用的是写后日志(mysql是写前日志)的方式，Redis先执行命令把数据写入内存，然后再记录日志到文件中。AOF日志记录的是操作命令，不是实际的数据，如果采用AOF方法做故障恢复时需要将全量日志都执行一遍。\n    \n    写后日志： 可能存在的风险\n        1. 数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。\n        2. 可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。\n        \n\n3. 混合持久化方式：Redis 4.0 新增了混合持久化的方式，集成了 RDB 和 AOF 的优点。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("h2",{attrs:{id:"keydb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keydb"}},[s._v("#")]),s._v(" keyDB")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("是一个在redis fork的分支，使用多线程实现，在承接redis内存数据的基础上，使用多线程处理数据写入读取请求，预计速度快5倍\n并且有主线程和worker线程。可以多个线程监听同一个端口。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h2",{attrs:{id:"缓存问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存问题"}},[s._v("#")]),s._v(" 缓存问题")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1.缓存雪崩：缓存中大部分缓存的key在同一个时间均失效（过期时间到期）、或者Redis突然宕机了，，导致大量的请求到达数据库，造成mysql查询压力。\n2.缓存击穿：在这个缓存过期的瞬间，并发查询同一条数据（缓存中没有，但是数据库中有的数据）\n3.缓存穿透：缓存中不存在的数据，数据库不存在的数据，可能是恶意攻击程序造成这种现象。\n          解决办法：使用布隆过滤器\n\n解决缓存雪崩的办法（防止key均在同一个时间过期的问题）：\n    设置缓存的过期时间是随机的（如果没有指定的过期时间），避免在同一个时间里，缓存大部分过期的情况。\n    如果缓存是分布式部署的，可以将热点数据均匀分布在不同的缓存数据库，并且设置热点数据永不过期（？可能需要动态的情况，依据具体业务而定）\n    \n    \n解决缓存雪崩的办法（redis宕机问题）：\n    1. 前： redis高可用： redis多节点，主从复制，哨兵模式实现高可用\n    2. 中： 做 ehcache 本地缓存、 Hystrix限流降级组件，避免mysql被过多的请求而导致阻塞\n            ehcache ： 系统收到请求后，先走 ehcache缓存，如果没有查到就走Redis缓存，如果Redis缓存没有，再查询数据库，随后将查询的数据同步到 ehcache 和 Redis 中\n            Hystrix ： 限流： 可以设置每秒的请求，有多少能通过组件，剩下未通过的请求就走降级处理，即是返回一些默认的值，或者友情提示 服务拥挤，暂时不可用\n                       好处：\n                            1. 数据库不会被请求挤压死，限流组件确保了只有多少个请求能到达mysql\n                            2. 只要数据库不会死，那么就有一部分的用户请求能被处理，剩下用户的请求，则需要提示其多试几次才会成功\n    3. 后： redis做数据持久化，redis宕机重启之后，迅速将缓存恢复\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br")])]),a("h2",{attrs:{id:"redis-client-on-error-error-write-epipe-config-right"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-client-on-error-error-write-epipe-config-right"}},[s._v("#")]),s._v(" Redis Client On Error: Error: write EPIPE Config right?")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("It sounds like you may be encountering an error when trying to write to a Redis client and are looking for information on how to configure it correctly.\n\nThe EPIPE error is typically encountered when the connection to the Redis server has been closed, either by the server or by the client. This can happen for a variety of reasons, such as if the server has been restarted, if there is a network issue, or if the client has exceeded the maximum number of connections allowed by the server.\n\nTo fix this error, you may need to check the configuration of your Redis client and server to ensure that they are properly connected and configured. Some specific things you can try include:\n\nMake sure that the Redis server is running and that the client is able to connect to it.\nCheck the client and server configuration settings to ensure that they are compatible.\nIf you are using a connection pool, make sure that it is properly configured and that it has enough connections available to handle the workload.\nCheck for any network issues that might be causing the connection to be lost.\nIf you continue to encounter this error after trying these suggestions, it may be helpful to check the logs for both the client and the server to see if there are any additional clues about the cause of the error.\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("h2",{attrs:{id:"redis慢日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis慢日志"}},[s._v("#")]),s._v(" redis慢日志")]),s._v(" "),a("ul",[a("li",[s._v("Redis延迟访问量突然增大，该怎么排查?   慢日志查询配置")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1.CONFIG SET slowlog_log_slower_than 8000 ——> 保留执行超过8s的记录日志\n2.CONFIG SET slowlog_max_len 1000 ——> 只保留最近1000条慢日志\n\n可能出现的原因：\n    1.存储的key过大 —— 这里就涉及到key命名规范性的考虑点\n    2.大量的key集中过期 —— 设置防抖key，增加随机数作为过期时间，避免大量的key集中同一时间过期\n过期策略： redis的过期策略是懒惰删除+定期删除\n    1.懒惰删除：当使用到这个key-value的时候，回去判断这个key是否过期，如果过期就立即删除该key-value\n    2.定期删除：定时扫描数据库，查看key-value是否过期\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("h2",{attrs:{id:"redis-json转义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-json转义"}},[s._v("#")]),s._v(" redis JSON转义")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('关于数据源切换的问题，当修改A库的时候，需要把相关输入入库到B，\n但是当前数据源的是A，所以当前的请求无法对B进行操作\n所以这里可以使用消息队列的方式实现这个功能，\n我采用的是redis实现的轻量消息框架，因为rbmq需要开服务，可能存在宕机的问题\n所以采用越少越好的原则。\n可能有个一问题，就是使用json的时候在redis中存取，会出现多首尾多了 "  ，或者是使用 /"进行了转义，\n尝试过截取首尾 " ，并把转义的 /" 替换，但是似乎没有起作用，所以使用了存字符串用逗号进行分割。\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("h2",{attrs:{id:"redis安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis安装"}},[s._v("#")]),s._v(" redis安装")]),s._v(" "),a("h3",{attrs:{id:"_1-redis的配置文件解析-redis6的配置文件和之前的版本有点小区别-主从模块-参考redis配置文件、redis6配置文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis的配置文件解析-redis6的配置文件和之前的版本有点小区别-主从模块-参考redis配置文件、redis6配置文件"}},[s._v("#")]),s._v(" 1. redis的配置文件解析: redis6的配置文件和之前的版本有点小区别（主从模块），参考redis配置文件、redis6配置文件")]),s._v(" "),a("h3",{attrs:{id:"_2-redis容器化启动-需要配置-redis-conf-配置文件-参考上面的配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis容器化启动-需要配置-redis-conf-配置文件-参考上面的配置"}},[s._v("#")]),s._v(" 2. redis容器化启动，需要配置 redis.conf 配置文件，参考上面的配置")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("version: '3'\nservices:\n  redis-master:\n    image: redis:7.0.9\n    container_name: redis-master-MQZ\n    restart: on-failure\n    volumes:\n      - /root/logs/docker-log/redis/master:/data\n      - /root/mqz/redis/redis-master.conf:/etc/redis/redis.conf\n    environment:\n      - TZ=Asia/Shanghai\n    command: redis-server /etc/redis/redis.conf\n    ports:\n      - \"6379:6379\"\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("h1",{attrs:{id:"redis-应用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-应用场景"}},[s._v("#")]),s._v(" redis 应用场景")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[s._v("缓存\n数据共享分布式： 分布式session spring-session-data-redis\n分布式锁\n全局ID： incrby 利用原子性\n计数器\n限流\n位统计： 在线用户统计、留存用户统计  = setbit onlineusers 01\n购物车： stirng、hash\n用户消息时间线timeline\n消息队列\n抽奖\n点赞、签到、打卡\n商品标签\n商品筛选\n用户关注、推荐模型\n排行榜：\n")])])]),a("h2",{attrs:{id:"_1-基本数据类型的存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本数据类型的存储"}},[s._v("#")]),s._v(" 1. 基本数据类型的存储：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    - string 字符串，底层数据结构： sds\n    - list 数组，底层数据结构：zip\n    - map（hash） 字典，底层数据结构：ziplist，dict\n    - set 集合，底层数据结构：intset,dict\n    - zset 有序集合，底层数据结构：ziplist，skiptable跳表\n    - bitmap 位图，底层数据结构：\n    - Pubsub 发布订阅，底层数据结构：\n    - GEO 地理位置 （有限使用，附近的人），底层数据结构：\n    - Stream 流（5.0） 和kafakaf非常像，底层数据结构：radix-tree基数\n    - Hyperlog 基数统计，底层数据结构：\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("h2",{attrs:{id:"_2-计数器-分布式id生成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-计数器-分布式id生成"}},[s._v("#")]),s._v(" 2. 计数器-分布式ID生成：")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://gitee.com/DemoMeng/better-skills.git",target:"_blank",rel:"noopener noreferrer"}},[s._v("https://gitee.com/DemoMeng/better-skills.git"),a("OutboundLink")],1),s._v(" 的a-lock模块")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    increment\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"_3-排行榜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-排行榜"}},[s._v("#")]),s._v(" 3. 排行榜：")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    zset中的有一个score参数，是这个排序的分值，这个是和set的区别之处\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"_4-好友关系、白名单、点赞列表、好友列表、双向关注列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-好友关系、白名单、点赞列表、好友列表、双向关注列表"}},[s._v("#")]),s._v(" 4. 好友关系、白名单、点赞列表、好友列表、双向关注列表")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    set 和 zset都是不允许重复的数据结构\n    其中 zset 有一个score（double）的属性，可以用来存储一个时间戳，用来标明建立关系锁发生的时间等，有明确的业务意义\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("h2",{attrs:{id:"_5-分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-分布式锁"}},[s._v("#")]),s._v(" 5. 分布式锁")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    redisson 实现分布式锁\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"_6-分布式限流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-分布式限流"}},[s._v("#")]),s._v(" 6. 分布式限流")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    1. 使用redis的java客户端redisson实现：\n        trySetRate(RateType rateType,long rate,long time,RateIntervalUnit.SECONDS)\n        tryAcquire(long rate)\n    2. 使用redis的incr和 expire 配合使用实现限流\n    3. nginx限流、sentiel\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("h2",{attrs:{id:"_7-消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-消息队列"}},[s._v("#")]),s._v(" 7. 消息队列")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    1. 配置RedisMessageListenerContainer监听器\n    2. 配置MessageListenerAdapter数据适配器，指定MessageConsumer对象（需要MessageListener监听接口）\n    具体参考MessageController & MesssageTests 类\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"_8-lbs-location-base-service-基于位置的数据服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-lbs-location-base-service-基于位置的数据服务"}},[s._v("#")]),s._v(" 8. LBS (Location Base Service) 基于位置的数据服务")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("geoadd命令\n\n1. 两地距离计算\n2. 附近的人、附近的充电桩、附近的东西等等...\n参考项目中 redis-web/test/RedisWebApplicationTests 测试用例\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("h2",{attrs:{id:"redis-如何实现key的自动清理-过期策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-如何实现key的自动清理-过期策略"}},[s._v("#")]),s._v(" Redis 如何实现key的自动清理（过期策略）")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("内存淘汰机制是在内存不够用（redis可设置内存值低于某值可触发内存淘汰机制）才会触发的一种机制。\n而过期策略是指的redis在对key过期之后如果处理这些key。我们会设置的一些key会指定过期时间，如 expire key-name 30。 \n\n1. 内存淘汰机制： 当服务器内存不够是触发的机制，参考redis.conf文件\n    # MAXMEMORY POLICY: 淘汰策略方式：\n    # LRU ： Least Recently Used ： 最近最少使用\n    # volatile-lru -> （设置过期时间的key）根据过期时间先后,使用 LRU 算法进行筛选删除\n    # allkeys-lru -> 使用 LRU 算法进行筛选删除\n    # volatile-random -> 设置了过期时间的key随机删除\n    # allkeys->random -> 随机删除\n    # volatile-ttl -> 根据过期时间先后进行删除，越早过期的越先被删除\n    # noeviction -> 默认淘汰策略，此策略不会对缓存的数据进行淘汰，当内存不够了就会报错，可以保证数据不会丢失\n    # The default is:\n    # maxmemory-policy volatile-lru\n    # Redis4.0后新增了两个策略\n    # LFU : Least Frequently Used : 最不常使用\n    # allkeys-lfu -> 所有的key按照LFU的算法进行淘汰\n    # volatile-lft —> 设置了过期时间的key按照LFU算法进行淘汰\n\n\n2. 过期策略：\n    a: 惰性删除 \n        redis不会主动去删除已经过期的key，所以该key即使已经过期了，但是还是存在数据库中。只有当客户端发起请求获取该key时，redis会先检查\n        该key是否已经过期，如果已经过期了则会触发'惰性删除'并返回null给客户端。\n        \n        缺点： 可能会造成空间资源浪费（过期的key若未被访问则永远存在数据库中）\n     \n    b: 定期删除 \n        redis每隔一段时间会检查数据库，是否有过期的key。若有过期的key就会被删除。\n        配置 redis.conf 中的 hz 10 默认是每秒扫描10次。\n        \n        定期删除的原理是，Redis会将所有设置了过期时间的key放入一个字典中，\n        然后每隔一段时间从字典中随机一些key检查过期时间并删除已过期的key。\n        Redis默认每秒进行10次过期扫描：\n        从过期字典中随机20个key\n        删除这20个key中已过期的\n        如果超过25%的key过期，则重复第一步\n        同时，为了保证不出现循环过度的情况，Redis还设置了扫描的时间上限，默认不会超过25ms。\n                    \n        hz默认设为10，提高它的值将会占用更多的cpu，当然相应的redis将会更快的处理同时到期的许多key，以及更精确的去处理超时。\n        hz的取值范围是1~500，通常不建议超过100，只有在请求延时非常低的情况下可以将值提升到100。\n        hz 10\n        \n    如果有太多的key，执行定期删除的方式会扫描全表占用较大的资源，定期删除是随机抽取一些key进行删除，这样有可能删不完，所以需要配合惰性删除。 \n\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br"),a("span",{staticClass:"line-number"},[s._v("45")]),a("br"),a("span",{staticClass:"line-number"},[s._v("46")]),a("br")])]),a("h2",{attrs:{id:"redis-和-memcached-的区别和共同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-和-memcached-的区别和共同点"}},[s._v("#")]),s._v(" Redis 和 Memcached 的区别和共同点")]),s._v(" "),a("ul",[a("li",[s._v("共同点 ：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1. 都是基于内存的数据库，一般都用来当做缓存使用。\n2. 都有过期策略。\n3. 两者的性能都非常高。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("ul",[a("li",[s._v("区别 ：")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("1. Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\n2. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。\n3. Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。\n4. Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。\n5. Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。\n6. Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。 （Redis 6.0 引入了多线程 IO ）\n7. Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。\n8. Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。\n9. 相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br")])]),a("h2",{attrs:{id:"redis底层数据结构是如何用跳表来存储数据的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis底层数据结构是如何用跳表来存储数据的"}},[s._v("#")]),s._v(" Redis底层数据结构是如何用跳表来存储数据的")]),s._v(" "),a("p",[a("a",{attrs:{"data-fancybox":"",title:"111",href:"Redis底层数据结构是如何用跳表来存储数据的.png"}},[a("img",{attrs:{src:"Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84.png",alt:"img.png"}})])])])}),[],!1,null,null,null);e.default=t.exports}}]);